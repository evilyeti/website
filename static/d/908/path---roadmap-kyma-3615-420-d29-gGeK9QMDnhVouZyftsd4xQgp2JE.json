{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n## Scope\r\n\r\n\r\nThe API Gateway capability aims to provide a set of functionalities allowing developers to expose, secure and manage their API's in an easy way. \r\nBased on the Service Mesh capability, it provides a common way to plug in security (authorization & authentication), enable routing and accessibility for all created APIs.\r\nAn API can be any application (lambda, GO application, etc.)\r\n\r\n\r\n\r\n## Vision\r\n\r\n\r\n* Extend authorization strategies for APIs\r\n\t* OAuth2 server issuing access tokens for exposed Kyma APIs (both user, and non-user oriented tokens)\r\n\t* OAuth2 proxy securing exposed APIs in Kyma, allowing access based on issued access tokens \r\n\t* Enable [Open Policy Agent](https://www.openpolicyagent.org/) policies for authorization and admission control\r\n\t* Support refreshing OAuth2 tokens\t\r\n\t\r\n* Traffic management for APIs\r\n\t* Control outbound traffic for APIs - define a list of external services which the API can access\r\n\t* Control internal API traffic - specify which services can access APIs internally\r\n\t* Traffic management for different API versions - split traffic between different versions of one API\r\n\t* API failure prevention - enable setting circuit breakers for APIs\r\n\t  \r\n* Enable developers to create and expose APIs separated on the Namespace level\r\n    * Allow applications to be exposed with Namespace name as a part of their hostname\r\n    * Allow blocking communication between services living in different Namespaces\r\n    \r\n* Enable easy adoption of GraphQl in APIs \r\n    * Allow legacy/microservice/serverless applications to be exposed and visible as GraphQl APIs \r\n    * Automate configuration and deployment of front end proxies to allow communication using GraphQl\r\n  \r\n* Expose services running on different environments\r\n    * Allow proxying requests to services running outside of Kyma - on Cloud Foundry, other Kubernetes clusters etc.\r\n    * Allow configuring the same authentication and authorization policies as for services deployed in Kyma\r\n    \r\n\t\r\n","fields":{"slug":"/undefined/api-gateway","type":"api-gateway"},"frontmatter":{"displayName":"API Gateway","epicsLabels":["area/service-mesh","quality/security"],"id":"api-gateway"}}},{"node":{"rawMarkdownBody":"\n## Scope\n\nThe Application Connectivity capability supports the extensibility and integration between applications in a cloud-native way using the best available solutions.\nIt provides integration patterns and necessary tooling for establishing a trusted connection between Kyma and third-party applications.\n\nThe goal is to enable the integration of various systems in a coherent way, where the management and usage of APIs and Events are standardized and allow to extend such systems in a natural, cloud-native way.\nThe unification of the connected system enables fast development which unlocks brand new possibilities for extending and customizing the existing solution in a modern, cloud-based, way.\n\nA new way of system scalability is available. The event mechanism and simple access to the exposed API is a foundation for moving the workload from a legacy system to Kubernetes.\n\nAn additional benefit is that you can mesh different systems using the language of your choice.\n\nThe integration must be as simple as possible.\n\n## Vision\n\n* Application Registry and Discoverability\n\n    * Connected application can register its APIs and Event catalogs. \n    * The registration contains the configuration of the endpoints together with required security credentials, documentation of the API and Event catalog based on open standards like OpenAPI and AsyncAPI, and additional documentation.\n    * Registered APIs and Event catalogs will be exposed as virtual services in Service Catalog.\n    * The registration of the application contains the required metadata, like health endpoints, localization, version.\n    \n* Events integration\n    * The event integration functionality provides required middleware for delivery of the business events to Kyma.\n    * The support for delivery guarantee, monitoring, and tracing is added.\n    \n* Access to the registered APIs\n    * The access to API exposed by a connected application is provided, and all requests are proxied by the delivered proxy service.\n    * The proxy service is handling the authentication and authorization, integration with monitoring and tracing. Various standard security mechanisms are provided to ensure the identity of the application. The support for OAuth, Basic auth, client certificates, CSRF tokes and more must be delivered.\n    * The Service Catalog binding controls the access to the proxy service and therefore to the API. The development effort is reduced to the required minimum, and all the boiler-plate code is packed into connectors.\n    \n* Connectors\n    * In the case of integration with the legacy system, which is not exposed using open standards such as REST, or if it is hidden behind a network firewall, the connectors will be provided.\n    * The connector ensures that a legacy system will be exposed in the same way as other systems, and the required translation of the API calls or events will be handled. \n    * The palette of provided connectors should be kept to the necessary minimum and wherever possible, the industry standards must be used.\n","fields":{"slug":"/undefined/application-connectivity","type":"application-connectivity"},"frontmatter":{"displayName":"Application Connectivity","epicsLabels":["area/application-connector"],"id":"application-connectivity"}}},{"node":{"rawMarkdownBody":"\n## Scope\n\nThe Console/Microfrontends capability relates to the way in which a user interacts with the Kyma UI. It drives the development of the Console, a modular and extensible web user interface for managing all aspects of Kyma.\n\n## Vision\n\n* User Experience\n\n    * Provide easy and intuitive user interfaces for Kyma to support its users in the best possible way.\n    * Focus on a consistent user experience based on unified [Fiori 3 Fundamentals](https://sap.github.io/fundamental/components/index.html) style guides.\n    * Enable most common user journeys in the UI so that usage of CLI is not required.\n    * Don't hide the Kubernetes nature from the user but extend it with Kyma-specific user guidance.\n\n* Extensibility & Modularity\n\n    * Use [Luigi orchestration framework](https://github.com/kyma-project/luigi) as UI extension mechanism to ease customization.\n    * Compose user interfaces from modular and highly reusable UI components.\n    * Ensure consistent and correct usage of microfrontend-hosting.\n\n* Fast & Responsive\n    \n    * Quick loading time for user interfaces\n    * Load only the essential data that is needed for rendering user interfaces and nothing more (use GraphQL).\n    * Give the user feedback for his actions (use websockets).\n\n","fields":{"slug":"/undefined/console-microfrontends","type":"console-microfrontends"},"frontmatter":{"displayName":"Console / Microfrontends","epicsLabels":["area/console","area/luigi"],"id":"console-microfrontends"}}},{"node":{"rawMarkdownBody":"\n## Scope\n\nThe Core and Supporting capability provides functionalities required to deliver the content and its visual representation. For us, content is not only regular documentation but also specifications and contextual help.\nDue to the nature of the content and the number of different areas it sits in, the Core and Supporting capability provides also many generic tools that not only support content but also other aspects of the product.\n\nIn other words, if some content must be displayed in a given UI, the capability cares also about the rest of the UI of a given business functionality and its backend.\n\n## Vision\n\n- Content is written once and reused in different contexts in an efficient way on the documentation portal, as the inline help, or in the UI applications. In other words, we provide a headless CMS that is an abstraction layer on top of a more generic files storage solution that allows you to store any static content, such as client-side applications. This is possible because of:\n  - The Kubernetes-native way of delivering content that supports distributed content sourcing and modularity. It means that content is delivered only if the documented component is enabled.\n  - Generic reusable UI components for rendering documentation and specifications that are reusable in any context. For example, you can use them in the Service Catalog view to display documentation for ServiceClasses and their instances or in the Applications view to display the documentation of connected applications.\n  - Providing the UI support for rendering specifications such as Swagger for REST API, EDM for OData, or AsyncApi for any kind of asynchronous communication.\n  - The backend that allows for the reuse of content and specification details in any UI context.\n- To support the out-of-the-box rendering of content in the Console UI and also make it easy for the Kyma users to generate a standalone documentation portal for their services.\n- To support easy content development, enable templates integration, and allow for previewing the content before publishing.\n- To support automated content validation, like links, grammar, consistency, and specification compliance.\n\n\n\n","fields":{"slug":"/undefined/core-and-supporting","type":"core-and-supporting"},"frontmatter":{"displayName":"Core & Supporting","epicsLabels":["area/core-and-supporting"],"id":"core-and-supporting"}}},{"node":{"rawMarkdownBody":"\n## Scope\n\nEventing helps you to deliver the following business use cases:\n\n* Extend existing applications by capturing the business events and triggering business extensions developed in Kyma.\n* Integrate two or more applications through business events.\n*Allow the application developers to define workflows to achieve a business scenario.\n* Enable integrating third-party messaging systems, including Cloud PubSub solutions.\n\n## Vision\n\n* Enable customers to plug in messaging middleware that fits their requirements best as well as to run multiple messaging implementations in parallel.\n* Provide **Health metrics** and **Performance metrics** for Event Bus to enable smooth operations and proactive actions.\n* Provide tooling to enable customers to benchmark Event Bus for their volume or fan-out needs.\n* Align with [CloudEvents specification](https://github.com/cloudevents/spec).\n* Provide a user interface for creating Event triggers for services deployed using Kyma.\n* Filter Events and transfer only those with existing subscriptions (triggers).\n* Generate Events inside a Kyma cluster and use them to enable asynchronous processing.\n* Support sending multiple Events in a single request.\n* Enable the subscriber to configure the backoff applied when the Event Bus retries to deliver the Events.\n* Support semantics allowing to move the message to a dead letter queue if not processed by a lambda function or a service.\n* Enable the possibility of assigning Event attributes and specifying Event durability.\n","fields":{"slug":"/undefined/eventing","type":"eventing"},"frontmatter":{"displayName":"Eventing","epicsLabels":["area/eventing"],"id":"eventing"}}},{"node":{"rawMarkdownBody":"\n ## Scope\nEnable the operator and developer to easily observe the state of the Kyma cluster and distributed applications running on Kyma. The pre-bundled infrastructure exposes and collects the data through application logs and metrics as well as transaction traces. This infrastructure integrates with the cloud provider-specific tools.\n\n\n ## Vision\nIn a cloud-native microservice architecture, a user request often flows through dozens of different microservices. Tools such as logging and monitoring provide insights on the health and state of a particular component. Based on the results, you can act proactively and reactively to maintain or recover the health of a component. Tracing enriches observability by identifying transaction traces across the different components.\n\nTo support application observability and follow the batteries included philosophy, Kyma would provide lightweight and cloud-native solutions for logging, tracing and monitoring. Such solutions enable developers and operators to easily query all application health data across the different workloads in development and production environments.\n\nThis includes the following features:\n* Setting up and maintaining optional, lightweight, and cloud-native solutions for logging, tracing and monitoring.\n* As much as possible data derived out of the box from Kubernetes and the Service Mesh.\n* Support for local development with Minikube.\n* Pluggability of all pre-bundled tooling by having well defined interfaces in place.\n* Ready-to use adapters to integrate easily with the tooling provided by the cloud providers, especially DynaTrace for monitoring.\n* Easily accessible and secure API and UI/CLI to query logs, traces and metrics.\n* Namespace separation support.\n* Support of transactional event logs such as audit logs.\n* Support for auto-scaling based on application metrics.\n* Proactive and reactive alerting for potential unhealthy cluster components.\n* Pre-integration with notification systems for alerting, such as VictorOps and Slack.\n* End-to-end tracing of distributed applications including eventing and external system connectivity.\n","fields":{"slug":"/undefined/logging-tracing-monitoring","type":"logging-tracing-monitoring"},"frontmatter":{"displayName":"Logging / Tracing / Monitoring","epicsLabels":["area/logging","area/tracing","area/monitoring"],"id":"logging-tracing-monitoring"}}},{"node":{"rawMarkdownBody":"<!-- above metadata will be used on kyma.project.io page to display nice name of capability and have a reference to label that should be used while fetching from ZenHub/GitHub the information about related Epics and their delivery plan   -->\n\n## Scope\n\nThe Serverless Runtime capability offering is a central part of the serverless strategy of Kyma. It is the easiest way to run custom code in Kyma and to integrate different services provided by the Services Brokers and the Application Connector. Following the \"batteries included\" rule of Kyma, the function-as-a-service (FaaS) solution based on Knative is provided inside the OSS Project. Apart from having the FaaS solution, it is also possible to schedule workloads on third-party offerings using Knative.\n\n## Vision\n\nThe goal of Serverless Runtime capability is to:\n\n- Provide a simple FaaS runtime as a part of Kyma.\n- Enable an easy deployment from version control systems.\n- Allow fast feedback loops for development and testing.\n- Integrate third-party serverless providers using Knative.\n- Integrate both Kyma and third-party FaaS solutions with other services provided by Kyma, such as Eventing, API, Service Catalog.\n- Provide an easy way to run containerized workloads inside and outside Kyme using Knative.\n- Provide helpers/sdk/utilities to eliminate boilerplate code.\n","fields":{"slug":"/undefined/runtime","type":"runtime"},"frontmatter":{"displayName":"Serverless Runtime","epicsLabels":["area/serverless"],"id":"serverless"}}},{"node":{"rawMarkdownBody":"\n## Scope\n\nThe Service Management capability wraps up the Service Catalog and the Service Brokers concepts. It enables applications that run in Kubernetes clusters to easily use internally and externally managed software offerings, such as a datastore service offered by a cloud provider. It also provides a way to list, provision, and automatically bind applications with services from the Service Brokers, with no need for detailed knowledge about how those services are created or managed.\n\n## Vision\n\nThe goal of the Service Management capability is to:\n* Ensure a well-configured and hardened installation of the Service Catalog.\n* Provide simple and self-guided Service Catalog UI flows.\n* Assure that the Service Catalog UI functionality always goes hand in hand with the Service Catalog CLI.\n* Support the Service Catalog with UI as a stand-alone solution.\n* Support automated service binding injection into various types of Kubernetes applications. \n* Allow registering new types of Kubernetes applications at runtime.\n* Enable connected remote applications in the Service Catalog using the Application Broker.\n* Enable extending the Service Catalog offerings with services that will be installed in Kubernetes using the Helm Broker and the `bundles` repository.\n* Provide a set of reusable services as bundles that will extend the Kyma installation.\n* Allow users to choose a set of Namespaces where a given Service Broker will be automatically registered and available. \n* Allow users to reduce a number of Service Classes that will be exposed by a given Broker.\n* Assure that the Service Catalog UI component for bindings is used in Deployment, Function, and other types of applications UI views.\n\n\n","fields":{"slug":"/undefined/service-management","type":"service-management"},"frontmatter":{"displayName":"Service Management","epicsLabels":["area/service-catalog"],"id":"service-management"}}}]}},"pageContext":{"capabilitiesNavigation":[{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Application Connectivity","id":"application-connectivity"},{"displayName":"Console / Microfrontends","id":"console-microfrontends"},{"displayName":"Core & Supporting","id":"core-and-supporting"},{"displayName":"Eventing","id":"eventing"},{"displayName":"Logging / Tracing / Monitoring","id":"logging-tracing-monitoring"},{"displayName":"Serverless Runtime","id":"serverless"},{"displayName":"Service Management","id":"service-management"}],"ids":{"API Gateway":"api-gateway","Application Connectivity":"application-connectivity","Console / Microfrontends":"console-microfrontends","Core & Supporting":"core-and-supporting","Eventing":"eventing","Logging / Tracing / Monitoring":"logging-tracing-monitoring","Serverless Runtime":"serverless","Service Management":"service-management"},"ticket":{"title":"Review new AsyncAPI 2.0","body":"**Description**\r\n\r\n- take specs we are now getting from one of the integrated applications (there apis are not yet open sources unfortunately...soon though) and manually rewrite to AsyncAPI 2 to identify differences and amount of changes that are on the way, especially how we will now identify the event types\r\n- take a look on https://github.com/asyncapi/parser and https://github.com/asyncapi/parser-nodejs that we will use in future for parsing the spec, give AsyncAPI guys feedback if you see some things can be improved, contribute if needed, but join their slack first and talk to them, they are nice people ;) Remember these are only official parsers and as you can see they are focused on server side parsing. Suggest what we do in future with client side components, how we use what asyncapi gives, what is the best and most reasonable. Of course keep in mind parser or course is also a validator\r\n- estimate how much time have to spend on refactoring the react component to support natively 2.0. What additional effort we have to put in the playground that is about to be converted into a official asyncapi editor\r\n- we need to support Kyma users with parsing 1.0 to 2.0, we can use Asset Store and have a mutator doing that during registration, how much time it can take (knowing we are not at the moment happy with how mutation and validation webhooks work. Keep in mind we also need to provide not only mutation service to rewrite, but also validation service to validate ;)\r\n- at the end, if needed, provide feedback to AsyncAPI squad (@fmvilas ) in such issue https://github.com/asyncapi/asyncapi/issues/new?assignees=&labels=v2.0.0+review&template=review.md&title=%5B2.0.0+REVIEW%5D+\r\n- take a look on this proposal from knative and see if our current events registry (the graphql query for returning events for a give namespace) has anything to do with the proposal https://github.com/knative/eventing/blob/a5e4762cd6537e52eebe1a1e432e77fa55877865/docs/registry/README.md\r\n\r\n**Reasons**\r\n\r\nWe depend on AsyncAPI, we are also AsyncAPI contributors, we need to clearly know what we will have to start implementing in 1.2 release schedule, which starts middle of May","url":"https://github.com/kyma-project/kyma/issues/3615","number":3615,"labels":["area/core-and-supporting","enhancement"],"githubUrl":"https://github.com/kyma-project/kyma/issues/3615","repository":{"name":"kyma","id":139590616,"issues":[]},"dueDate":"2019-06-07T10:00:00.000Z","zenHubUrl":"https://app.zenhub.com/workspaces/kyma---all-repositories-5b6d5985084045741e744dea/issues/kyma-project/kyma/3615","release":{"release_id":"5cb59383709ee87123145468","title":"1.2","description":"Release 1.2 - Istanbul","start_date":"2019-05-13T10:00:00.000Z","desired_end_date":"2019-06-07T10:00:00.000Z","created_at":"2019-04-16T08:34:11.381Z","closed_at":null,"state":"open"},"capability":{"displayName":"Core & Supporting","epicsLabels":["area/core-and-supporting"],"id":"core-and-supporting"}},"locale":"en"}}