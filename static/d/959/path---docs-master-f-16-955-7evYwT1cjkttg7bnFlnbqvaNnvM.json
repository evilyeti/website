{"pageContext":{"version":"master","versions":{"releases":["1.0","0.9","0.8","0.7","0.6","0.5","0.4"],"branches":["master"]},"content":{"id":"kyma","displayName":"Kyma","description":"Overall documentation for Kyma","type":"root","docs":[{"order":"01-01-in-a-nutshell","title":"In a nutshell","source":"\nKyma allows you to connect applications and third-party services in a cloud-native environment. Use it to create extensions for the existing systems, regardless of the language they are written in. Customize extensions with minimum effort and time devoted to learning their configuration details.\n\nFocus purely on coding with these out-of-the-box functionalities at hand:\n- Service-to-service communication and proxying (Istio Service Mesh)\n- In-built monitoring, tracing, and logging (Grafana, Prometheus, Jaeger, Loki)\n- Secure authentication and authorization (Dex, Service Identity, TLS, Role Based Access Control)\n- The catalog of services to choose from (Service Catalog, Service Brokers)\n- The development platform to run lightweight functions in a cost-efficient and scalable way (Serverless, Kubeless)\n- The endpoint to register Events and APIs of external applications (Application Connector)\n- The messaging channel to receive Events, enrich them, and trigger business flows using lambdas or services (Event Bus, NATS)\n- CLI supported by the intuitive UI (Console)\n","type":"Overview"},{"order":"01-02-main-features","title":"Main features","source":"\nMajor open-source and cloud-native projects, such as Istio, NATS, Kubeless, and Prometheus, constitute the cornerstone of Kyma. Its uniqueness, however, lies in the \"glue\" that holds these components together. Kyma collects those cutting-edge solutions in one place and combines them with the in-house developed features that allow you to connect and extend your enterprise applications easily and intuitively.\n\nKyma allows you to extend and customize the functionality of your products in a quick and modern way, using serverless computing or microservice architecture. The extensions and customizations you create are decoupled from the core applications, which means that:\n- Deployments are quick.\n- Scaling is independent from the core applications.\n- The changes you make can be easily reverted without causing downtime of the production system.\n\nLast but not least, Kyma is highly cost-efficient. All Kyma native components and the connected open-source tools are written in Go. It ensures low memory consumption and reduced maintenance costs compared to applications written in other programming languages such as Java.\n","type":"Overview"},{"order":"01-03-technology-stack","title":"Technology stack","source":"\nThe entire solution is containerized and runs on a [Kubernetes](https://kubernetes.io/) cluster. Customers can access it easily using a single sign on solution based on the [Dex](https://github.com/coreos/dex) identity provider integrated with any [OpenID Connect](https://openid.net/connect/)-compliant identity provider or a SAML2-based enterprise authentication server.\n\nThe communication between services is handled by the [Istio](https://istio.io/) Service Mesh component which enables security, traffic management, routing, resilience (retry, circuit breaker, timeouts), monitoring, and tracing without the need to change the application code.\nBuild your applications using services provisioned by one of the many Service Brokers compatible with the [Open Service Broker API](https://www.openservicebrokerapi.org/), and monitor the speed and efficiency of your solutions using [Prometheus](https://prometheus.io/), which gives you the most accurate and up-to-date monitoring data.\n","type":"Overview"},{"order":"01-04-key-components","title":"Key components","source":"\nKyma is built of numerous components but these three drive it forward:\n\n  - **Application Connector**:\n    - Simplifies and secures the connection between external systems and Kyma\n    - Registers external Events and APIs in the Service Catalog and simplifies the API usage\n    - Provides asynchronous communication with services and lambdas deployed in Kyma through Events\n    - Manages secure access to external systems\n    - Provides monitoring and tracing capabilities to facilitate operational aspects\n  - **Serverless**: \n    - Ensures quick deployments following a lambda function approach\n    - Enables scaling independent of the core applications\n    - Gives a possibility to revert changes without causing production system downtime\n    - Supports the complete asynchronous programming model\n    - Offers loose coupling of Event providers and consumers\n    - Enables flexible application scalability and availability\n  - **Service Catalog**:\n    - Connects services from external sources\n    - Unifies the consumption of internal and external services thanks to compliance with the Open Service Broker standard\n    - Provides a standardized approach to managing the API consumption and access\n    - Eases the development effort by providing a catalog of API and Event documentation to support automatic client code generation\n  \n\nThis basic use case shows how the three components work together in Kyma:\n\n![key-components](./assets/ac-s-sc.svg)\n","type":"Overview"},{"order":"01-05-kyma-and-knative","title":"Kyma and Knative - brothers in arms","source":"\nIntegration with Knative is a step towards Kyma modularization and the \"slimming\" approach which aims to extract some out-of-the-box components and provide you with a more flexible choice of tools to use in Kyma.\n\nBoth Kyma and Knative are Kubernetes and Istio-based systems that offer development and eventing platforms. The main difference, however, is their focus. While Knative concentrates more on providing the building blocks for running serverless workloads, Kyma focuses on integrating those blocks with external services and applications.\n\nThe diagram shows dependencies between the components:\n\n![kyma-knative](./assets/kyma-knative.svg)\n\nKyma and Knative cooperation focuses on replacing Kyma eventing with Knative eventing, and Kyma Serverless with Knative serving.\n","type":"Overview"},{"order":"01-06-how-to-start","title":"How to start","source":"\nMinikube allows you to run Kyma locally, develop, and test your solutions on a small scale before you push them to a cluster. With the Installation and Getting Started guides at hand, you can start developing in a matter of minutes.\n\nRead, learn, and try on your own to:\n\n- [Install Kyma locally](#installation-install-kyma-locally)\n- [Install Kyma on a cluster](#installation-install-kyma-on-a-cluster)\n- [Deploy a sample service locally](#tutorials-sample-service-deployment-on-local)\n- [Deploy a service on a cluster](#tutorials-sample-service-deployment-on-a-cluster)\n- [Develop a service locally without using Docker](#tutorials-develop-a-service-locally-without-using-docker)\n- [Publish a service Docker image and deploy it to Kyma](#tutorials-publish-a-service-docker-image-and-deploy-it-to-kyma)\n- [Configure the Installer with override values for Helm charts](#tutorials-helm-overrides-for-kyma-installation)\n- [Register a Broker in Service Catalog](/docs/master/components/service-catalog#tutorials-register-a-broker-in-the-service-catalog)\n- [Create a new Application](/docs/master/components/application-connector#tutorials-create-a-new-application)\n- [Get the client certificate](/docs/master/components/application-connector#tutorials-get-the-client-certificate)\n- [Register a service](/docs/master/components/application-connector#tutorials-register-a-service)\n- [Bind an Application to a Namespace](/docs/master/components/application-connector#tutorials-bind-an-application-to-a-namespace)\n- [Trigger a lambda with events](/docs/master/components/application-connector#tutorials-trigger-a-lambda-with-events)\n- [Call a registered external service from Kyma](/docs/master/components/application-connector#tutorials-call-a-registered-external-service-from-kyma)\n- [Expose custom metrics in Kyma](/docs/master/components/monitoring#tutorials-expose-custom-metrics-in-kyma)\n","type":"Overview"},{"order":"03-01-components","title":"Components","source":"\nKyma is built on the foundation of the best and most advanced open-source projects which make up the components readily available for customers to use.\nThis section describes the Kyma components.\n\n## Service Catalog\n\nThe Service Catalog lists all of the services available to Kyma users through the registered [Service Brokers](/docs/master/components/service-catalog/#service-brokers-service-brokers). Use the Service Catalog to provision new services in the\nKyma [Kubernetes](https://kubernetes.io/) cluster and create bindings between the provisioned service and an application.\n\n\n## Service Mesh\n\nThe Service Mesh is an infrastructure layer that handles service-to-service communication, proxying, service discovery, traceability, and security independent of the code of the services. Kyma uses the [Istio](https://istio.io/) Service Mesh that is customized for the specific needs of the implementation.\n\n## Security\n\nKyma security enforces RBAC (Role Based Access Control) in the cluster. [Dex](https://github.com/coreos/dex) handles the identity management and identity provider integration. It allows you to integrate any [OpenID Connect](https://openid.net/connect/) or SAML2-compliant identity provider with Kyma using [connectors](https://github.com/coreos/dex#connectors). Additionally, Dex provides a static user store which gives you more flexibility when managing access to your cluster.   \n\n## Helm Broker\n\nThe Helm Broker is a Service Broker which runs in the Kyma cluster and deploys Kubernetes native resources using [Helm](https://github.com/kubernetes/helm) and Kyma bundles. A bundle is an abstraction layer over a Helm chart which allows you to represent it as a ClusterServiceClass in the Service Catalog. Use bundles to install the [GCP Broker](/docs/master/components/service-catalog#service-brokers-gcp-broker) and the [Azure Service Broker](/docs/master/components/service-catalog#service-brokers-azure-service-broker) in Kyma.\n\n## Application Connector\n\nThe Application Connector is a proprietary Kyma solution. This endpoint is the Kyma side of the connection between Kyma and the external solutions. The Application Connector allows you to register the APIs and the Event Catalog, which lists all of the available events, of the connected solution. Additionally, the Application Connector proxies the calls from Kyma to external APIs in a secure way.\n\n## Event Bus\n\nKyma Event Bus receives Events from external solutions and triggers the business logic created with lambda functions and services in Kyma. The Event Bus is based on the [NATS Streaming](https://nats.io/) open source messaging system for cloud-native applications.\n\n## Serverless\n\nThe Kyma Serverless component allows you to reduce the implementation and operation effort of an application to the absolute minimum. Kyma Serverless provides a platform to run lightweight functions in a cost-efficient and scalable way using JavaScript and Node.js. Kyma Serverless is built on the [Kubeless](http://kubeless.io/) framework, which allows you to deploy lambda functions,\nand uses the [NATS](https://nats.io/) messaging system that monitors business events and triggers functions accordingly.  \n\n## Monitoring\n\nKyma comes bundled with tools that give you the most accurate and up-to-date monitoring data. [Prometheus](https://prometheus.io/) open source monitoring and alerting toolkit provides this data, which is consumed by different add-ons, including [Grafana](https://grafana.com/) for analytics and monitoring, and [Alertmanager](https://prometheus.io/docs/alerting/alertmanager/) for handling alerts.\n\n## Tracing\n\nThe tracing in Kyma uses the [Jaeger](https://github.com/jaegertracing) distributed tracing system. Use it to analyze performance by scrutinizing the path of the requests sent to and from your service. This information helps you optimize the latency and performance of your solution.\n\n## Logging\n\nLogging in Kyma uses [Loki](https://github.com/grafana/loki), a Prometheus-like log management system.\n","type":"Details"},{"order":"03-02-namespaces","title":"Namespaces","source":"\nA Namespace is a security and organizational unit which allows you to divide the cluster into smaller units to use for different purposes, such as development and testing.\n\nNamespaces available for users are marked with the `env: \"true\"` label. The Kyma UI only displays the Namespaces marked with the `env: \"true\"` label.\n\n\n## Default Kyma Namespaces\n\nKyma comes configured with default Namespaces dedicated for system-related purposes. The user cannot modify or remove any of these Namespaces.\n\n- `kyma-system` - This Namespace contains all of the Kyma Core components.\n- `kyma-integration` - This Namespace contains all of the Application Connector components responsible for the integration of Kyma and external solutions.\n- `kyma-installer` - This Namespace contains all of the Kyma Installer components, objects, and Secrets.\n- `istio-system` - This Namespace contains all of the Istio-related components.\n\n## Namespaces for users in Kyma\n\nKyma comes with three Namespaces ready for you to use.\n- `production`\n- `qa`\n- `stage`\n\n### Create a new Namespace for users\n\nCreate a Namespace and mark it with the `env: \"true\"` label to make it available for Kyma users. Use this command to do that in a single step:\n\n```\n$ cat <<EOF | kubectl create -f -\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: my-namespace\n  labels:\n    env: \"true\"\nEOF\n```\n\nInitially, the system deploys two template roles: `kyma-reader-role` and `kyma-admin-role`. The controller finds the template roles by filtering the roles available in the `kyma-system` Namespace by the label `env: \"true\"`. The controller copies these roles into the newly created Namespace.\n","type":"Details"},{"order":"03-03-testing","title":"Testing Kyma","source":"\nKyma components use [Octopus](http://github.com/kyma-incubator/octopus) for testing. \nOctopus is a testing framework that allows you to run tests defined as Docker images on a running cluster.\nOctopus uses two CustomResourceDefinitions (CRDs):\n- TestDefinition, which defines your test as a Pod specification.\n- ClusterTestSuite, which defines a suite of tests to execute and how to execute them.\n\n## Add a new test\nTo add a new test, create a `yaml` file with TestDefinition CR in your chart. To comply with the convention, place it under the `tests` directory.\nSee the exemplary chart structure for Dex:\n\n```\n# Chart tree\ndex\n├── Chart.yaml\n├── README.md\n├── templates\n│   ├── tests\n│   │   └── test-dex-connection.yaml\n│   ├── dex-deployment.yaml\n│   ├── dex-ingress.yaml\n│   ├── dex-rbac-role.yaml\n│   ├── dex-service.yaml\n│   ├── pre-install-dex-account.yaml\n│   ├── pre-install-dex-config-map.yaml\n│   └── pre-install-dex-secrets.yaml\n└── values.yaml\n```\n\nThe test adds a new **test-dex-connection.yaml** under the `templates/tests` directory.\nFor more information on TestDefinition, read the [Octopus documentation](https://github.com/kyma-incubator/octopus/blob/master/docs/crd-test-definition.md).\n\nThe following example presents TestDefinition with a container that calls the Dex endpoint with cURL. You must define at least the **spec.template** parameter which is of the `PodTemplateSpec` type.\n\n```yaml\napiVersion: \"testing.kyma-project.io/v1alpha1\"\nkind: TestDefinition\nmetadata:\n  name: \"test-{{ template \"fullname\" . }}-connection-dex\"\nspec:\n  template:\n    metadata:\n      annotations:\n        sidecar.istio.io/inject: \"false\"\n    spec:\n      containers:\n      - name: \"test-{{ template \"fullname\" . }}-connection-dex\"\n        image: tutum/curl:alpine\n        command: [\"/usr/bin/curl\"]\n        args: [\n          \"--fail\",\n          \"--max-time\", \"10\",\n          \"--retry\", \"60\",\n          \"--retry-delay\", \"3\",\n          \"http://dex-service.{{ .Release.Namespace }}.svc.cluster.local:5556/.well-known/openid-configuration\"\n        ]\n      restartPolicy: Never\n\n```\n\n## Tests execution\nTo run all tests, use the `testing.sh` script located in the `/installation/scripts/` directory. \nInternally, the ClusterTestSuite resource is defined. It fetches all TestDefinitions and executes them.\n\n\n### Run tests manually\nTo run tests manually, create your own ClusterTestSuite resource. See the following example:\n\n```yaml\napiVersion: testing.kyma-project.io/v1alpha1\nkind: ClusterTestSuite\nmetadata:\n  labels:\n    controller-tools.k8s.io: \"1.0\"\n  name: {my-suite}\nspec:\n  maxRetries: 0\n  concurrency: 1\n  count: 1\n```\n\nCreation of the suite triggers tests execution. See the current tests progress in the ClusterTestSuite status. Run:\n```bash\n kubectl get cts {my-suite} -oyaml\n ```\n \nThe sample output looks as follows:\n```\napiVersion: testing.kyma-project.io/v1alpha1\nkind: ClusterTestSuite\nmetadata:\n  name: {my-suite}\nspec:\n  concurrency: 1\n  count: 1\n  maxRetries: 0\nstatus:\n  conditions:\n  - status: \"True\"\n    type: Running\n  results:\n  - executions:\n    - completionTime: 2019-04-05T12:23:00Z\n      id: {my-suite}-test-dex-dex-connection-dex-0\n      podPhase: Succeeded\n      startTime: 2019-04-05T12:22:54Z\n    name: test-dex-dex-connection-dex\n    namespace: kyma-system\n    status: Succeeded\n  - executions:\n    - id: {my-suite}-test-core-core-ui-acceptance-0\n      podPhase: Running\n      startTime: 2019-04-05T12:37:53Z\n    name: test-core-core-ui-acceptance\n    namespace: kyma-system\n    status: Running\n  - executions: []\n    name: test-api-controller-acceptance\n    namespace: kyma-system\n    status: NotYetScheduled\n  startTime: 2019-04-05T12:22:53Z\n```\n\nThe ID of the test execution is the same as the ID of the testing Pod. The testing Pod is created in the same Namespace as its TestDefinition. To get logs for a specific test, run the following command:\n```\nkubectl logs {execution-id} -n {test-def-namespace}\n```","type":"Details"},{"order":"03-04-charts","title":"Charts","source":"\nKyma uses Helm charts to deliver single components and extensions, as well as the core components. This document contains information about the chart-related technical concepts, dependency management to use with Helm charts, and chart examples.\n\n## Manage dependencies with Init Containers\n\nThe **ADR 003: Init Containers for dependency management** document declares the use of Init Containers as the primary dependency mechanism.\n\n[Init Containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) present a set of distinctive behaviors:\n\n* They always run to completion.\n* They start sequentially, only after the preceding Init Container completes successfully.\n  If any of the Init Containers fails, the Pod restarts. This is always true, unless the `restartPolicy` equals `never`.\n\n[Readiness Probes](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes) ensure that the essential containers are ready to handle requests before you expose them. At a minimum, probes are defined for every container accessible from outside of the Pod. It is recommended to pair the Init Containers with readiness probes to provide a basic dependency management solution.\n\n## Examples\n\nHere are some examples:\n\n1. Generic\n\n\n```yaml\napiVersion: apps/v1beta2\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.7.9\n        ports:\n        - containerPort: 80\n        readinessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 30\n          timeoutSeconds: 1\n```\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: myapp-pod\nspec:\n  initContainers:\n  - name: init-myservice\n    image: busybox\n    command: ['sh', '-c', 'until nslookup nginx; do echo waiting for nginx; sleep 2; done;']\n  containers:\n  - name: myapp-container\n    image: busybox\n    command: ['sh', '-c', 'echo The app is running! && sleep 3600']\n```\n\n2. Kyma\n\n```yaml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: helm-broker\n  labels:\n    app: helm-broker\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: helm-broker\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 0\n  template:\n    metadata:\n      labels:\n        app: helm-broker\n    spec:\n\n      initContainers:\n      - name: init-helm-broker\n        image: eu.gcr.io/kyma-project/alpine-net:0.2.74\n        command: ['sh', '-c', 'until nc -zv service-catalog-controller-manager.kyma-system.svc.cluster.local 8080; do echo waiting for etcd service; sleep 2; done;']\n\n      containers:\n      - name: helm-broker\n        ports:\n        - containerPort: 6699\n        readinessProbe:\n          tcpSocket:\n            port: 6699\n          failureThreshold: 3\n          initialDelaySeconds: 10\n          periodSeconds: 3\n          successThreshold: 1\n          timeoutSeconds: 2\n```\n\n## Support for the Helm wait flag\n\nHigh level Kyma components, such as **core**, come as Helm charts. These charts are installed as part of a single Helm release. To provide ordering for these core components, the Helm client runs with the `--wait` flag. As a result, Tiller waits for the readiness of all of the components, and then evaluates the readiness.\n\nFor `Deployments`, set the strategy to `RollingUpdate` and set the `MaxUnavailable` value to a number lower than the number of replicas. This setting is necessary, as readiness in Helm v2.10.0 is fulfilled if the number of replicas in ready state is not lower than the expected number of replicas:\n\n```\nReadyReplicas >= TotalReplicas - MaxUnavailable\n```\n\n## Chart installation details\n\nThe Tiller server performs the chart installation process. This is the order of operations that happen during the chart installation:\n\n* resolve values\n* recursively gather all templates with the corresponding values\n* sort all templates\n* render all templates\n* separate hooks and manifests from files into sorted lists\n* aggregate all valid manifests from all sub-charts into a single manifest file\n* execute PreInstall hooks\n* create a release using the ReleaseModule API and, if requested, wait for the actual readiness of the resources\n* execute PostInstall hooks\n\n## Notes\n\nAll notes are based on Helm v2.10.0 implementation and are subject to change in future releases.\n\n* Regardless of how complex a chart is, and regardless of the number of sub-charts it references or consists of, it's always evaluated as one. This means that each Helm release is compiled into a single Kubernetes manifest file when applied on API server.\n\n* Hooks are parsed in the same order as manifest files and returned as a single, global list for the entire chart. For each hook the weight is calculated as a part of this sort.\n\n* Manifests are sorted by `Kind`. You can find the list and the order of the resources on the Kubernetes [Tiller](https://github.com/kubernetes/helm/blob/v2.10.0/pkg/tiller/kind_sorter.go#L29) website.\n\n## Glossary\n\n* **resource** is any document in a chart recognized by Helm or Tiller. This includes manifests, hooks, and notes.\n* **template** is a valid Go template. Many of the resources are also Go templates.\n","type":"Details"},{"order":"03-05-deploy-private-registry","title":"Deploy with a private Docker registry","source":"\nDocker is a free tool to deploy applications and servers. To run an application on Kyma, provide the application binary file as a Docker image located in a Docker registry. Use the `DockerHub` public registry to upload your Docker images for free access to the public. Use a private Docker registry to ensure privacy, increased security, and better availability.\n\nThis document shows how to deploy a Docker image from your private Docker registry to the Kyma cluster.\n\n## Details\n\nThe deployment to Kyma from a private registry differs from the deployment from a public registry. You must provide Secrets accessible in Kyma, and referenced in the `.yaml` deployment file. This section describes how to deploy an image from a private Docker registry to Kyma. Follow the deployment steps:\n\n1. Create a Secret resource.\n2. Write your deployment file.\n3. Submit the file to the Kyma cluster.\n\n### Create a Secret for your private registry\n\nA Secret resource passes your Docker registry credentials to the Kyma cluster in an encrypted form. For more information on Secrets, refer to the [Kubernetes documentation](https://kubernetes.io/docs/concepts/configuration/secret/).\n\nTo create a Secret resource for your Docker registry, run the following command:\n\n```bash\nkubectl create secret docker-registry {secret-name} --docker-server={registry FQN} --docker-username={user-name} --docker-password={password} --docker-email={registry-email} --namespace={namespace}  \n```\n\nRefer to the following example:\n```bash\nkubectl create secret docker-registry docker-registry-secret --docker-server=myregistry:5000 --docker-username=root --docker-password=password --docker-email=example@github.com --namespace=production\n```\n\nThe Secret is associated with a specific Namespace. In the example, the Namespace is `production`. However, you can modify the Secret to point to any desired Namespace.\n\n### Write your deployment file\n\n1. Create the deployment file with the `.yml` extension and name it `deployment.yml`.\n\n2. Describe your deployment in the `.yml` file. Refer to the following example:\n\n```yaml\napiVersion: apps/v1beta2\nkind: Deployment\nmetadata:\n  namespace: production # {production/stage/qa}\n  name: my-deployment # Specify the deployment name.\n  annotations:\n    sidecar.istio.io/inject: true\nspec:\n  replicas: 3 # Specify your replica - how many instances you want from that deployment.\n  selector:\n    matchLabels:\n      app: app-name # Specify the app label. It is optional but it is a good practice.\n  template:\n    metadata:\n      labels:\n        app: app-name # Specify app label. It is optional but it is a good practice.\n        version: v1 # Specify your version.\n    spec:\n      containers:\n      - name: container-name # Specify a meaningful container name.\n        image: myregistry:5000/user-name/image-name:latest # Specify your image {registry FQN/your-username/your-space/image-name:image-version}.\n        ports:\n          - containerPort: 80 # Specify the port to your image.\n      imagePullSecrets:\n        - name: docker-registry-secret # Specify the same Secret name you generated in the previous step for this Namespace.\n        - name: example-secret-name # Specify your Namespace Secret, named `example-secret-name`.\n\n```\n3. Submit you deployment file using this command:\n\n```bash\nkubectl apply -f deployment.yml\n```\nYour deployment is now running on the Kyma cluster.\n","type":"Details"},{"order":"04-01-overview","title":"Overview","source":"\nKyma is a complex tool which consists of many different [components](#details-components) that provide various functionalities to extend your application. This entails high technical requirements that can influence your local development process. To meet the customer needs, we ensured Kyma modularity. This way you can decide not to include a given component in the Kyma installation, or install it after the Kyma installation process.\n\nTo make the local development process easier, we introduced the **Kyma Lite** concept in which case some components are not included in the local installation process by default. These are the Kyma and Kyma Lite components:\n\n| Component | Kyma | Kyma Lite |\n|----------------|------|------|\n| `core` | ✅ | ✅ |\n| `cms` | ✅ | ✅ |\n| `cluster-essentials` | ✅ | ✅ |\n| `application-connector` | ✅ | ✅ |\n| `ark` | ✅ | ⛔️ |\n| `assetstore` | ✅ | ✅ |\n| `dex` | ✅ | ✅ |\n| `helm-broker` | ✅ | ✅ |\n| `istio` | ✅ | ✅ |\n| `istio-kyma-patch` | ✅ | ✅ |\n| `jaeger` | ✅ | ⛔️ |\n| `logging` | ✅ | ⛔️ |\n| `monitoring` | ✅ | ⛔️ |\n| `prometheus-operator` | ✅ | ⛔️ |\n| `service-catalog` | ✅ | ✅ |\n| `service-catalog-addons` | ✅ | ✅ |\n| `nats-streaming` | ✅ | ✅ |\n\n## Installation guides\n\nFollow these installation guides to install Kyma locally or on a cluster:\n\n- [Install Kyma locally](#installation-install-kyma-locally)\n- [Install Kyma on a cluster](#installation-install-kyma-on-a-cluster)\n\nRead rest of the installation documents to learn how to:\n- [Disable the selected components' installation or install them separately](#installation-custom-component-installation)\n- [Update Kyma](#installation-update-kyma)\n- [Reinstall Kyma](#installation-reinstall-kyma)\n- [Get in-depth knowledge about the installation scripts](#installation-local-installation-scripts-deep-dive)\n\n>**NOTE:** Make sure to check whether the version of the documentation in the left pane of the `kyma-project.io` is compatible with your Kyma version.\n","type":"Installation"},{"order":"04-02-local-installation","title":"Install Kyma locally","source":"\nThis Installation guide shows developers how to quickly deploy Kyma locally on the MacOS and Linux platforms. Kyma is installed locally using a proprietary installer based on a [Kubernetes operator](https://coreos.com/operators/). The document provides prerequisites, instructions on how to install Kyma locally and verify the deployment, as well as the troubleshooting tips.\n\n## Prerequisites\n\nTo run Kyma locally, clone [this](https://github.com/kyma-project/kyma) Git repository to your machine and check out the latest release.\n\nAdditionally, download these tools:\n\n- [Docker](https://www.docker.com/get-started)\n- [Minikube](https://github.com/kubernetes/minikube) 0.33.0\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.12.0\n- [Helm](https://github.com/kubernetes/helm) 2.10.0\n- [jq](https://stedolan.github.io/jq/)\n- [wget](https://www.gnu.org/software/wget/)\n\nVirtualization:\n\n- [Hyperkit driver](https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#hyperkit-driver) - Mac only\n- [VirtualBox](https://www.virtualbox.org/) - Linux only\n\n> **NOTE:** To work with Kyma, use only the provided scripts and commands. Kyma does not work on a basic Minikube cluster that you can start using the `minikube start` command.\n\n## Set up certificates\n\nKyma comes with a local wildcard self-signed `server.crt` certificate that you can find under the `/installation/certs/workspace/raw/` directory of the `kyma` repository. Trust it on the OS level for convenience.\n\nFollow these steps to \"always trust\" the Kyma certificate on MacOS:\n\n1. Change the working directory to `installation`:\n\n  ```\n  cd installation\n  ```\n\n2. Run this command:\n\n  ```\n  sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain certs/workspace/raw/server.crt\n  ```\n\n>**NOTE:** \"Always trusting\" the certificate does not work with Mozilla Firefox.\n\nTo access the Application Connector and connect an external solution to the local deployment of Kyma, you must add the certificate to the trusted certificate storage of your programming environment. Read [this](/docs/master/components/application-connector#details-access-the-application-connector-on-a-local-kyma-deployment) document to learn more.\n\n## Install Kyma\n\nYou can install Kyma either with all core subcomponents or only with the selected ones. This section describes how to install Kyma with all core subcomponents. Read [this](/docs/master/root/kyma#configuration-custom-component-installation) document to learn how to install only the selected subcomponents.\n\n  > **CAUTION:** Running the installation script deletes any previously existing cluster from your Minikube.\n\n  > **NOTE:** Logging and Monitoring subcomponents are not included by default when you install Kyma on Minikube. You can install them using the instructions provided [here](https://github.com/kyma-project/kyma/tree/master/resources).\n\nFollow these instructions to install Kyma from a release or from local sources:\n<div tabs>\n  <details>\n  <summary>\n  From a release\n  </summary>\n\n  1. Change the working directory to `installation`:\n      ```\n      cd installation\n      ```\n\n  2. Use the following command to run Kubernetes locally using Minikube:\n      ```\n      ./scripts/minikube.sh --domain \"kyma.local\" --vm-driver \"hyperkit\"\n      ```\n\n  3. Wait until the `kube-dns` Pod is ready. Run this script to setup Tiller:\n      ```\n      ./scripts/install-tiller.sh\n      ```\n\n  4. Go to [this](https://github.com/kyma-project/kyma/releases/) page and choose the latest release.\n\n  5. Export the release version as an environment variable. Run:\n      ```\n      export LATEST={KYMA_RELEASE_VERSION}\n      ```\n\n  6. Deploy the Kyma Installer in your cluster from the `$LATEST` release:\n      ```\n      kubectl apply -f https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-installer-local.yaml\n      ```\n\n  7. Configure the Kyma installation using the local configuration file from the `$LATEST` release:\n      ```\n      wget -qO- https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-config-local.yaml | sed \"s/minikubeIP: \\\"\\\"/minikubeIP: \\\"$(minikube ip)\\\"/g\" | kubectl apply -f -\n      ```\n\n  8. To trigger the installation process, label the `kyma-installation` custom resource:\n      ```\n      kubectl label installation/kyma-installation action=install\n      ```\n\n  9. By default, the Kyma installation is a background process, which allows you to perform other tasks in the terminal window. Nevertheless, you can track the progress of the installation by running this script:\n      ```\n      ./scripts/is-installed.sh\n      ```\n</details>\n<details>\n<summary>\nFrom sources\n</summary>\n\nTo start the local installation from sources, run this command:\n\n```\n./installation/cmd/run.sh\n```\n\nThis script sets up default parameters, starts Minikube, builds the Kyma Installer, generates local configuration, creates the Installation custom resource, and sets up the Installer.\n\n> **NOTE:** See [this](#installation-local-installation-scripts-deep-dive) document for a detailed explanation of the `run.sh` script and the subscripts it triggers.\n\nYou can execute the `installation/cmd/run.sh` script with the following parameters:\n\n- `--password {YOUR_PASSWORD}` which allows you to set a password for the **admin@kyma.cx** user.\n- `--skip-minikube-start` which skips the execution of the `installation/scripts/minikube.sh` script.\n- `--vm-driver` which points to either `virtualbox` or `hyperkit`, depending on your operating system.\n  </details>\n</div>\n\nRead [this](#installation-reinstall-kyma) document to learn how to reinstall Kyma without deleting the cluster from Minikube.\nTo learn how to test Kyma, see [this](#details-testing-kyma) document.\n\n## Verify the deployment\n\nFollow the guidelines in the subsections to confirm that your Kubernetes API Server is up and running as expected.\n\n### Verify the installation status using the is-installed.sh script\n\nThe `is-installed.sh` script is designed to give you clear information about the Kyma installation. Run it at any point to get the current installation status, or to find out whether the installation is successful.\n\nIf the script indicates that the installation failed, try to install Kyma again by re-running the `run.sh` script.\n\nIf the installation fails in a reproducible manner, don't hesitate to create a [GitHub](https://github.com/kyma-project/kyma/issues) issue in the project or reach out to the [\"installation\" Slack channel](https://kyma-community.slack.com/messages/CD2HJ0E78) to get direct support from the community.\n\n### Access the Kyma console\n\nAccess your local Kyma instance through [this](https://console.kyma.local/) link.\n\n* Click **Login with Email** and sign in with the **admin@kyma.cx** email address. Use the password contained in the  `admin-user` Secret located in the `kyma-system` Namespace. To get the password, run:\n\n``` bash\nkubectl get secret admin-user -n kyma-system -o jsonpath=\"{.data.password}\" | base64 --decode\n```\n\n* Click the **Namespaces** section and select a Namespace from the drop-down menu to explore Kyma further.\n\n\n## Enable Horizontal Pod Autoscaler (HPA)\n\nBy default, the Horizontal Pod Autoscaler (HPA) is not enabled in your local Kyma installation, so you need to enable it manually.\n\nKyma uses the `autoscaling/v1` stable version, which supports only CPU autoscaling. Once enabled, HPA automatically scales the number of lambda function Pods based on the observed CPU utilization.\n\n>**NOTE:** The `autoscaling/v1` version does not support custom metrics. To use such metrics, you need the `autoscaling/v2beta1` version.\n\nFollow these steps to enable HPA:\n\n1. Enable the metrics server for resource metrics by running the following command:\n  ```\n  minikube addons enable metrics-server\n  ```\n\n2. Verify if the metrics server is active by checking the list of addons:\n  ```\n  minikube addons list\n  ```\n\n## Stop and restart Kyma without reinstalling\n\nUse the `minikube.sh` script to restart the Minikube cluster without reinstalling Kyma. Follow these steps to stop and restart your cluster:\n\n1. Stop the Minikube cluster with Kyma installed. Run:\n  ```\n  minikube stop\n  ```\n2. Restart the cluster without reinstalling Kyma. Run:\n  ```\n  ./scripts/minikube.sh --domain \"kyma.local\" --vm-driver \"hyperkit\"\n  ```\n\nThe script discovers that a Minikube cluster is initialized and asks if you want to delete it. Answering `no` causes the script to start the Minikube cluster and restarts all of the previously installed components. Even though this procedure takes some time, it is faster than a clean installation as you don't download all of the required Docker images.\n\nTo verify that the restart is successful, run this command and check if all Pods have the `RUNNING` status:\n\n```\nkubectl get pods --all-namespaces\n```\n\n## Troubleshooting\n\n1. If the Installer does not respond as expected, check the installation status using the `is-installed.sh` script with the `--verbose` flag added. Run:\n   ```\n   scripts/is-installed.sh --verbose\n   ```\n\n2. If the installation is successful but a component does not behave in an expected way, see if all deployed Pods are running. Run this command:\n   ```\n   kubectl get pods --all-namespaces\n   ```\n\n   The command retrieves all Pods from all Namespaces, the status of the Pods, and their instance numbers. Check if the STATUS column shows Running for all Pods. If any of the Pods that you require do not start successfully, perform the installation again.\n\n   If the problem persists, don't hesitate to create a [GitHub](https://github.com/kyma-project/kyma/issues) issue or reach out to the [\"installation\" Slack channel](https://kyma-community.slack.com/messages/CD2HJ0E78) to get direct support from the community.\n\n3. If you put your local running cluster into hibernation or use `minikube stop` and `minikube start` the date and time settings of Minikube get out of sync with the system date and time settings. As a result, the access token used to log in cannot be properly validated by Dex and you cannot log in to the console. To fix that, set the date and time used by your machine in Minikube. Run:\n   ```\n   minikube ssh -- docker run -i --rm --privileged --pid=host debian nsenter -t 1 -m -u -n -i date -u $(date -u +%m%d%H%M%Y)\n   ```\n","type":"Installation"},{"order":"04-03-cluster-installation","title":"Install Kyma on a cluster","source":"\nThis installation guide explains how you can quickly deploy Kyma on a cluster with a wildcard DNS provided by [`xip.io`](http://xip.io).\n\n>**NOTE:** If you have your own domain and want to use it during installation, follow [this](#installation-use-your-own-domain) guide.\n\nKyma cluster installation comes down to these steps:\n\n1. Preparation of the cluster\n2. Preparation of the configuration file\n3. Kyma deployment\n\nThe guide explains how to prepare the configuration file from the latest GitHub release. If you want to use your own image, follow [these](#installation-use-your-own-kyma-installer-image) steps.\nAdditionally, if you need to use Helm and access Tiller securely, complete [additional configuration](#installation-use-helm) at the end of the installation procedure.\n\nChoose your cloud provider and get started:\n\n<div tabs>\n  <details>\n  <summary>\n  GKE\n  </summary>\n\n\nInstall Kyma on a [Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine/) (GKE) cluster.\n\n## Prerequisites\n- [Google Cloud Platform](https://console.cloud.google.com/) (GCP) project with Kubernetes Engine API enabled\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.12.0\n- [Docker](https://www.docker.com/)\n- [Docker Hub](https://hub.docker.com/) account\n- [gcloud](https://cloud.google.com/sdk/gcloud/)\n- [wget](https://www.gnu.org/software/wget/)\n\n## Installation process\n\n### Prepare the GKE cluster\n\n1. Select a name for your cluster. Set the cluster name and the name of your GCP project as environment variables. Run:\n    ```\n    export CLUSTER_NAME={CLUSTER_NAME_YOU_WANT}\n    export PROJECT={YOUR_GCP_PROJECT}\n    ```\n\n2. Create a cluster in the `europe-west1` region. Run:\n    ```\n    gcloud container --project \"$PROJECT\" clusters \\\n    create \"$CLUSTER_NAME\" --zone \"europe-west1-b\" \\\n    --cluster-version \"1.12\" --machine-type \"n1-standard-4\" \\\n    --addons HorizontalPodAutoscaling,HttpLoadBalancing\n    ```\n\n3. Install Tiller on your GKE cluster. Run:\n\n    ```\n    kubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/{RELEASE_TAG}/installation/resources/tiller.yaml\n    ```\n\n4. Add your account as the cluster administrator:\n    ```\n    kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account)\n    ```\n\n### Prepare the configuration file\n\nUse the GitHub release 0.8 or higher.\n\n1. Go to [this](https://github.com/kyma-project/kyma/releases/) page and choose the latest release.\n\n2. Export the release version as an environment variable. Run:\n    ```\n    export LATEST={KYMA_RELEASE_VERSION}\n    ```\n\n3. Download the `kyma-config-cluster.yaml` and `kyma-installer-cluster.yaml` files from the latest release. Run:\n   ```\n   wget https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-config-cluster.yaml\n   wget https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-installer-cluster.yaml\n   ```\n\n4. Prepare the deployment file.\n\n    - Run this command:\n    ```\n    cat kyma-installer-cluster.yaml <(echo -e \"\\n---\") kyma-config-cluster.yaml | sed -e \"s/__.*__//g\" > my-kyma.yaml\n    ```\n\n    - Alternatively, run this command if you deploy Kyma with GKE version 1.12.6-gke.X and above:\n\n    ```\n    cat kyma-installer-cluster.yaml <(echo -e \"\\n---\") kyma-config-cluster.yaml | sed -e \"s/__PROMTAIL_CONFIG_NAME__/promtail-k8s-1-14.yaml/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n    ```\n\n5. The output of this operation is the `my_kyma.yaml` file. Use it to deploy Kyma on your GKE cluster.\n\n\n### Deploy Kyma\n\n1. Configure kubectl to use your new cluster. Run:\n    ```\n    gcloud container clusters get-credentials $CLUSTER_NAME --zone europe-west1-b --project $PROJECT\n    ```\n\n2. Deploy Kyma using the `my-kyma` custom configuration file you created. Run:\n    ```\n    kubectl apply -f my-kyma.yaml\n    ```\n\n3. Check if the Pods of Tiller and the Kyma Installer are running:\n    ```\n    kubectl get pods --all-namespaces\n    ```\n\n4. Start Kyma installation:\n    ```\n    kubectl label installation/kyma-installation action=install\n    ```\n\n5. To watch the installation progress, run:\n    ```\n    while true; do \\\n      kubectl -n default get installation/kyma-installation -o jsonpath=\"{'Status: '}{.status.state}{', description: '}{.status.description}\"; echo; \\\n      sleep 5; \\\n    done\n    ```\nAfter the installation process is finished, the `Status: Installed, description: Kyma installed` message appears.\nIn case of an error, you can fetch the logs from the Installer by running:\n    ```\n    kubectl -n kyma-installer logs -l 'name=kyma-installer'\n    ```\n\n## Post-installation steps\n\n### Add the xip.io self-signed certificate to your OS trusted certificates\n\nAfter the installation, add the custom Kyma [`xip.io`](http://xip.io/) self-signed certificate to the trusted certificates of your OS. For MacOS, run:\n  ```\n  tmpfile=$(mktemp /tmp/temp-cert.XXXXXX) \\\n  && kubectl get configmap  net-global-overrides -n kyma-installer -o jsonpath='{.data.global\\.ingress\\.tlsCrt}'  | base64 --decode > $tmpfile \\\n  && sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $tmpfile \\\n  && rm $tmpfile\n  ```\n\n### Access the cluster\n\n  1. To get the address of the cluster's Console, check the host of the Console's virtual service. The name of the host of this virtual service corresponds to the Console URL. To get the virtual service host, run:\n\n  ```\n  kubectl get virtualservice core-console -n kyma-system\n  ```\n\n  2. Access your cluster under this address:\n\n  ```\n  https://{VIRTUAL_SERVICE_HOST}\n  ```\n\n> **NOTE:** To log in to your cluster, use the default `admin` static user. To learn how to get the login details for this user, see [this](#installation-install-kyma-locally-access-the-kyma-console) document.\n\n\n  </details>\n  <details>\n  <summary>\n  AKS\n  </summary>\n\n\nInstall Kyma on an [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) (AKS) cluster.\n\n## Prerequisites\n\n- [Microsoft Azure](https://azure.microsoft.com)\n- [Kubernetes](https://kubernetes.io/) 1.12\n- Tiller 2.10.0 or higher\n- [Docker](https://www.docker.com/)\n- [Docker Hub](https://hub.docker.com/) account\n- [az](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)\n\n## Installation process\n\n### Prepare the AKS cluster\n\nSet the following environment variables:\n1. Select a name for your cluster. Set the cluster name, the resource group and region as environment variables. Run:\n  ```\n  export RS_GROUP={YOUR_RESOURCE_GROUP_NAME}\n  export CLUSTER_NAME={YOUR_CLUSTER_NAME}\n  export REGION={YOUR_REGION} #westeurope\n  ```\n\n2. Create a resource group that will contain all your resources:\n   ```\n   az group create --name $RS_GROUP --location $REGION\n   ```\n\n3. Create an AKS cluster. Run:\n    ```\n    az aks create \\\n      --resource-group $RS_GROUP \\\n      --name $CLUSTER_NAME \\\n      --node-vm-size \"Standard_DS2_v2\" \\\n      --kubernetes-version 1.10.9 \\\n      --enable-addons \"monitoring,http_application_routing\" \\\n      --generate-ssh-keys\n    ```\n4. To configure kubectl to use your new cluster, run:\n    ```\n    az aks get-credentials --resource-group $RS_GROUP --name $CLUSTER_NAME\n    ```\n\n5. Install Tiller and add additional privileges to be able to access readiness probes endpoints on your AKS cluster.\n\n    * Installation from release\n    ```\n    kubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/$KYMA_RELEASE_VERSION/installation/resources/tiller.yaml\n    kubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/$KYMA_RELEASE_VERSION/installation/resources/azure-crb-for-healthz.yaml\n    ```\n    * If you install Kyma from sources, check out [kyma-project](https://github.com/kyma-project/kyma) and enter the root folder. Run:\n    ```\n    kubectl apply -f installation/resources/tiller.yaml\n    kubectl apply -f installation/resources/azure-crb-for-healthz.yaml\n\n    ```\n\n### Prepare the configuration file\n\nUse the GitHub release 0.8 or higher.\n\n1. Go to [this](https://github.com/kyma-project/kyma/releases/) page and choose the latest release.\n\n2. Export the release version as an environment variable. Run:\n    ```\n    export LATEST={KYMA_RELEASE_VERSION}\n    ```\n\n3. Download the `kyma-config-cluster.yaml` and `kyma-installer-cluster.yaml` files from the latest release. Run:\n   ```\n   wget https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-config-cluster.yaml\n   wget https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-installer-cluster.yaml\n   ```\n\n4. Prepare the deployment file.\n\n    - Run this command:\n    ```\n    cat kyma-installer-cluster.yaml <(echo -e \"\\n---\") kyma-config-cluster.yaml | sed -e \"s/__PROXY_EXCLUDE_IP_RANGES__/10.0.0.1/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n    ```\n\n    - Alternatively, run this command if you deploy Kyma with Kubernetes version 1.14 and above:\n    ```\n    cat kyma-installer-cluster.yaml <(echo -e \"\\n---\") kyma-config-cluster.yaml | sed -e \"s/__PROMTAIL_CONFIG_NAME__/promtail-k8s-1-14.yaml/g\" | sed -e \"s/__PROXY_EXCLUDE_IP_RANGES__/10.0.0.1/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n    ```\n\n5. The output of this operation is the `my_kyma.yaml` file. Use it to deploy Kyma on your GKE cluster.\n\n### Deploy Kyma\n\n1. Deploy Kyma using the `my-kyma` custom configuration file you created. Run:\n    ```\n    kubectl apply -f my-kyma.yaml\n    ```\n    >**NOTE:** If you get `Error from server (MethodNotAllowed)`, run the command again before proceeding to the next step.\n\n2. Check if the Pods of Tiller and the Kyma Installer are running:\n    ```\n    kubectl get pods --all-namespaces\n    ```\n\n3. Start Kyma installation:\n    ```\n    kubectl label installation/kyma-installation action=install\n    ```\n\n4. To watch the installation progress, run:\n    ```\n    while true; do \\\n      kubectl -n default get installation/kyma-installation -o jsonpath=\"{'Status: '}{.status.state}{', description: '}{.status.description}\"; echo; \\\n      sleep 5; \\\n    done\n    ```\nAfter the installation process is finished, the `Status: Installed, description: Kyma installed` message appears.\nIn case of an error, you can fetch the logs from the Installer by running:\n    ```\n    kubectl -n kyma-installer logs -l 'name=kyma-installer'\n    ```\n\n\n## Post-installation steps\n\n### Add the xip.io self-signed certificate to your OS trusted certificates\n\nAfter the installation, add the custom Kyma [`xip.io`](http://xip.io/) self-signed certificate to the trusted certificates of your OS. For MacOS, run:\n```\ntmpfile=$(mktemp /tmp/temp-cert.XXXXXX) \\\n&& kubectl get configmap cluster-certificate-overrides -n kyma-installer -o jsonpath='{.data.global\\.tlsCrt}' | base64 --decode > $tmpfile \\\n&& sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $tmpfile \\\n&& rm $tmpfile\n```\n\n### Access the cluster\n\n1. To get the address of the cluster's Console, check the host of the Console's virtual service. The name of the host of this virtual service corresponds to the Console URL. To get the virtual service host, run:\n\n```\nkubectl get virtualservice core-console -n kyma-system\n```\n\n2. Access your cluster under this address:\n\n```\nhttps://{VIRTUAL_SERVICE_HOST}\n```\n\n>**NOTE:** To log in to your cluster, use the default `admin` static user. To learn how to get the login details for this user, see [this](#installation-install-kyma-locally-access-the-kyma-console) document.\n\n\n  </details>\n</div>\n","type":"Installation"},{"order":"04-04-use-your-own-domain","title":"Use your own domain","source":"\nThis guide explains how to deploy Kyma on a cluster using your own domain.\n\n>**TIP:** Get a free domain for your cluster using services like [freenom.com](https://www.freenom.com) or similar.\n\nChoose your cloud provider and get started:\n\n<div tabs>\n  <details>\n  <summary>\n  GKE\n  </summary>\n\n\nInstall Kyma on a [Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine/) (GKE) cluster.\n\n## Prerequisites\n- [Google Cloud Platform](https://console.cloud.google.com/) (GCP) project with Kubernetes Engine API enabled\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.12.0\n- [Docker](https://www.docker.com/)\n- [Docker Hub](https://hub.docker.com/) account\n- [gcloud](https://cloud.google.com/sdk/gcloud/)\n- [wget](https://www.gnu.org/software/wget/)\n- A domain for your GKE cluster\n\n## Prepare the GKE cluster\n\n1. Select a name for your cluster. Set the cluster name and the name of your GCP project as environment variables. Run:\n    ```\n    export CLUSTER_NAME={CLUSTER_NAME_YOU_WANT}\n    export PROJECT={YOUR_GCP_PROJECT}\n    ```\n\n2. Create a cluster in the `europe-west1` region. Run:\n    ```\n    gcloud container --project \"$PROJECT\" clusters \\\n    create \"$CLUSTER_NAME\" --zone \"europe-west1-b\" \\\n    --cluster-version \"1.12.5\" --machine-type \"n1-standard-4\" \\\n    --addons HorizontalPodAutoscaling,HttpLoadBalancing\n    ```\n\n3. Install Tiller on your GKE cluster. Run:\n\n    ```\n    kubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/{RELEASE_TAG}/installation/resources/tiller.yaml\n    ```\n\n4. Add your account as the cluster administrator:\n    ```\n    kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account)\n    ```\n\n## DNS setup and TLS certificate generation          \n\n### Delegate the management of your domain to Google Cloud DNS\n\nFollow these steps:\n\n1. Export the domain name, project name, and DNS zone name as environment variables. Run the commands listed below:\n\n    ```\n    export DOMAIN={YOUR_SUBDOMAIN}\n    export DNS_NAME={YOUR_DOMAIN}.\n    export PROJECT={YOUR_GOOGLE_PROJECT_ID}\n    export DNS_ZONE={YOUR_DNS_ZONE}\n    ```\n    Example:\n    ```\n    export DOMAIN=my.kyma-demo.ga\n    export DNS_NAME=kyma-demo.ga.\n    export PROJECT=kyma-demo-235208\n    export DNS_ZONE=myzone\n    ```\n\n2. Create a DNS-managed zone in your Google project. Run:\n\n    ```\n    gcloud dns --project=$PROJECT managed-zones create $DNS_ZONE --description= --dns-name=$DNS_NAME\n    ```\n\n    Alternatively, create it through the GCP UI. Navigate go to **Network Services** in the **Network** section, click **Cloud DNS** and select **Create Zone**.\n\n3. Delegate your domain to Google name servers.\n\n    - Get the list of the name servers from the zone details. This is a sample list:\n      ```\n      ns-cloud-b1.googledomains.com.\n      ns-cloud-b2.googledomains.com.\n      ns-cloud-b3.googledomains.com.\n      ns-cloud-b4.googledomains.com.\n      ```\n\n    - Set up your domain to use these name servers.\n\n4. Check if everything is set up correctly and your domain is managed by Google name servers. Run:\n    ```\n    host -t ns $DNS_NAME\n    ```\n    A successful response returns the list of the name servers you fetched from GCP.\n\n### Get the TLS certificate\n\n1. Create a folder for certificates. Run:\n    ```\n    mkdir letsencrypt\n    ```\n2. Create a new service account and assign it to the `dns.admin` role. Run these commands:\n    ```\n    gcloud iam service-accounts create dnsmanager --display-name \"dnsmanager\" --project \"$PROJECT\"\n    ```\n    ```\n    gcloud projects add-iam-policy-binding $PROJECT \\\n        --member serviceAccount:dnsmanager@$PROJECT.iam.gserviceaccount.com --role roles/dns.admin\n    ```\n\n3. Generate an access key for this account in the `letsencrypt` folder. Run:\n    ```\n    gcloud iam service-accounts keys create ./letsencrypt/key.json --iam-account dnsmanager@$PROJECT.iam.gserviceaccount.com\n    ```\n4. Run the Certbot Docker image with the `letsencrypt` folder mounted. Certbot uses the key to apply DNS challenge for the certificate request and stores the TLS certificates in that folder. Run:\n    ```\n    docker run -it --name certbot --rm \\\n        -v \"$(pwd)/letsencrypt:/etc/letsencrypt\" \\\n        certbot/dns-google \\\n        certonly \\\n        -m YOUR_EMAIL_HERE --agree-tos --no-eff-email \\\n        --dns-google \\\n        --dns-google-credentials /etc/letsencrypt/key.json \\\n        --server https://acme-v02.api.letsencrypt.org/directory \\\n        -d \"*.$DOMAIN\"\n    ```\n\n5. Export the certificate and key as environment variables. Run these commands:\n\n    ```\n    export TLS_CERT=$(cat ./letsencrypt/live/$DOMAIN/fullchain.pem | base64 | sed 's/ /\\\\ /g' | tr -d '\\n');\n    export TLS_KEY=$(cat ./letsencrypt/live/$DOMAIN/privkey.pem | base64 | sed 's/ /\\\\ /g' | tr -d '\\n')\n    ```\n\n## Prepare the configuration file\n\nUse the GitHub release 0.8 or higher.\n\n1. Go to [this](https://github.com/kyma-project/kyma/releases/) page and choose the latest release.\n\n2. Export the release version as an environment variable. Run:\n    ```\n    export LATEST={KYMA_RELEASE_VERSION}\n    ```\n\n3. Download the `kyma-config-cluster.yaml` and `kyma-installer-cluster.yaml` files from the latest release. Run:\n   ```\n   wget https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-config-cluster.yaml\n   wget https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-installer-cluster.yaml\n   ```\n\n4. Prepare the deployment file.\n\n    - Run this command:\n    ```\n    cat kyma-installer-cluster.yaml <(echo -e \"\\n---\") kyma-config-cluster.yaml | sed -e \"s/__DOMAIN__/$DOMAIN/g\" | sed -e \"s/__TLS_CERT__/$TLS_CERT/g\" | sed -e \"s/__TLS_KEY__/$TLS_KEY/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n    ```\n\n    - Alternatively, run this command if you deploy Kyma with GKE version 1.12.6-gke.X and above:\n    ```\n    cat kyma-installer-cluster.yaml <(echo -e \"\\n---\") kyma-config-cluster.yaml | sed -e \"s/__PROMTAIL_CONFIG_NAME__/promtail-k8s-1-14.yaml/g\" | sed -e \"s/__DOMAIN__/$DOMAIN/g\" | sed -e \"s/__TLS_CERT__/$TLS_CERT/g\" | sed -e \"s/__TLS_KEY__/$TLS_KEY/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n    ```\n\n5. The output of this operation is the `my_kyma.yaml` file. Use it to deploy Kyma on your GKE cluster.\n\n## Deploy Kyma\n\n1. Configure kubectl to use your new cluster. Run:\n    ```\n    gcloud container clusters get-credentials $CLUSTER_NAME --zone europe-west1-b --project $PROJECT\n    ```\n\n2. Deploy Kyma using the `my-kyma` custom configuration file you created. Run:\n    ```\n    kubectl apply -f my-kyma.yaml\n    ```\n\n3. Check if the Pods of Tiller and the Kyma Installer are running:\n    ```\n    kubectl get pods --all-namespaces\n    ```\n\n4. Start Kyma installation:\n    ```\n    kubectl label installation/kyma-installation action=install\n    ```\n\n5. To watch the installation progress, run:\n    ```\n    while true; do \\\n      kubectl -n default get installation/kyma-installation -o jsonpath=\"{'Status: '}{.status.state}{', description: '}{.status.description}\"; echo; \\\n      sleep 5; \\\n    done\n    ```\n    After the installation process is finished, the `Status: Installed, description: Kyma installed` message appears.\n    In case of an error, you can fetch the logs from the Installer by running:\n    ```\n    kubectl -n kyma-installer logs -l 'name=kyma-installer'\n    ```\n\n## Configure DNS for the cluster load balancer\n\n1. Export the domain of your cluster and DNS zone as environment variables. Run:\n    ```\n    export DOMAIN=$(kubectl get cm net-global-overrides -n kyma-installer -o jsonpath='{.data.global\\.ingress\\.domainName}')\n    export DNS_ZONE={YOUR_DNS_ZONE}\n    ```\n\n2. To add DNS entries, run these commands:\n    ```\n    export EXTERNAL_PUBLIC_IP=$(kubectl get service -n istio-system istio-ingressgateway -o jsonpath=\"{.status.loadBalancer.ingress[0].ip}\")\n\n    export APISERVER_PUBLIC_IP=$(kubectl get service -n kyma-system apiserver-proxy-ssl -o jsonpath=\"{.status.loadBalancer.ingress[0].ip}\")\n\n    export REMOTE_ENV_IP=$(kubectl get service -n kyma-system application-connector-ingress-nginx-ingress-controller -o jsonpath=\"{.status.loadBalancer.ingress[0].ip}\")\n\n    gcloud dns --project=$PROJECT record-sets transaction start --zone=$DNS_ZONE\n\n    gcloud dns --project=$PROJECT record-sets transaction add $EXTERNAL_PUBLIC_IP --name=\\*.$DOMAIN. --ttl=60 --type=A --zone=$DNS_ZONE\n\n    gcloud dns --project=$PROJECT record-sets transaction add $REMOTE_ENV_IP --name=\\gateway.$DOMAIN. --ttl=60 --type=A --zone=$DNS_ZONE\n\n    gcloud dns --project=$PROJECT record-sets transaction add $APISERVER_PUBLIC_IP --name=\\apiserver.$DOMAIN. --ttl=60 --type=A --zone=$DNS_ZONE\n\n    gcloud dns --project=$PROJECT record-sets transaction execute --zone=$DNS_ZONE\n    ```\n\n## Access the cluster\n\n1. To get the address of the cluster's Console, check the host of the Console's virtual service. The name of the host of this virtual service corresponds to the Console URL. To get the virtual service host, run:\n\n    ```\n    kubectl get virtualservice core-console -n kyma-system\n    ```\n\n2. Access your cluster under this address:\n\n    ```\n    https://{VIRTUAL_SERVICE_HOST}\n    ```\n>**NOTE:** To log in to your cluster, use the default `admin` static user. To learn how to get the login details for this user, see [this](#installation-install-kyma-locally-access-the-kyma-console) document.\n\n\n  </details>\n  <details>\n  <summary>\n  AKS\n  </summary>\n\n\nInstall Kyma on an [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) (AKS) cluster.\n\n## Prerequisites\n- [Microsoft Azure](https://azure.microsoft.com)\n- [Kubernetes](https://kubernetes.io/) 1.12\n- Tiller 2.10.0 or higher\n- [Docker](https://www.docker.com/)\n- [Docker Hub](https://hub.docker.com/) account\n- [az](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)\n- A domain for your AKS cluster\n\n## Prepare the AKS cluster\n\nSet the following environment variables:\n1. Select a name for your cluster. Set the cluster name, the resource group and region as environment variables. Run:\n  ```\n  export RS_GROUP={YOUR_RESOURCE_GROUP_NAME}\n  export CLUSTER_NAME={YOUR_CLUSTER_NAME}\n  export REGION={YOUR_REGION} #westeurope\n  ```\n\n2. Create a resource group that will contain all your resources:\n   ```\n   az group create --name $RS_GROUP --location $REGION\n   ```\n\n3. Create an AKS cluster. Run:\n    ```\n    az aks create \\\n      --resource-group $RS_GROUP \\\n      --name $CLUSTER_NAME \\\n      --node-vm-size \"Standard_DS2_v2\" \\\n      --kubernetes-version 1.10.9 \\\n      --enable-addons \"monitoring,http_application_routing\" \\\n      --generate-ssh-keys\n    ```\n4. To configure kubectl to use your new cluster, run:\n    ```\n    az aks get-credentials --resource-group $RS_GROUP --name $CLUSTER_NAME\n    ```\n\n5. Install Tiller and add additional privileges to be able to access readiness probes endpoints on your AKS cluster.\n    * Installation from release\n    ```\n    kubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/$KYMA_RELEASE_VERSION/installation/resources/tiller.yaml\n    kubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/$KYMA_RELEASE_VERSION/installation/resources/azure-crb-for-healthz.yaml\n    ```\n    * If you install Kyma from sources, check out [kyma-project](https://github.com/kyma-project/kyma) and enter the root folder. Run:\n    ```\n    kubectl apply -f installation/resources/tiller.yaml\n    kubectl apply -f installation/resources/azure-crb-for-healthz.yaml\n    ```\n\n## DNS setup and TLS certificate generation\n\n### Delegate the management of your domain to Azure DNS\n\nFollow these steps:\n\n1. Export the domain name, the sub-domain, and the resource group name as environment variables. Run these commands:\n\n    ```\n    export DNS_DOMAIN={YOUR_DOMAIN} # example.com\n    export SUB_DOMAIN={YOUR_SUBDOMAIN} # cluster (in this case the full name of your cluster is cluster.example.com)\n    export RS_GROUP={YOUR_RESOURCE_GROUP_NAME}\n    ```\n\n2. Create a DNS-managed zone in your Azure subscription. Run:\n\n    ```\n    az network dns zone create -g $RS_GROUP -n $DNS_DOMAIN\n    ```\n\n    Alternatively, create it through the Azure UI. In the **Networking** section, go to **All services**, click **DNS zones**, and select **Add**.\n\n3. Delegate your domain to Azure name servers.\n\n    - Get the list of the name servers from the zone details. This is a sample list:\n      ```\n      ns1-05.azure-dns.com.\n      ns2-05.azure-dns.net.\n      ns3-05.azure-dns.org.\n      ns4-05.azure-dns.info.\n      ```\n\n    - Set up your domain to use these name servers.\n\n4. Check if everything is set up correctly and your domain is managed by Azure name servers. Run:\n    ```\n    host -t ns $DNS_DOMAIN\n    ```\n    A successful response returns the list of the name servers you fetched from Azure.\n\n### Get the TLS certificate\n\n>**NOTE:** Azure DNS is not yet supported by Certbot so you must perform manual verification.\n\n1. Create a folder for certificates. Run:\n    ```\n    mkdir letsencrypt\n    ```\n2. Export your email address as an environment variable:\n    ```\n    export YOUR_EMAIL={YOUR_EMAIL}\n    ```\n3. To get the certificate, run the Certbot Docker image with the `letsencrypt` folder mounted. Certbot stores the TLS certificates in that folder.\n    ```\n    docker run -it --name certbot --rm \\\n        -v \"$(pwd)/letsencrypt:/etc/letsencrypt\" \\\n        certbot/certbot \\\n        certonly \\\n        -m $YOUR_EMAIL --agree-tos --no-eff-email \\\n        --manual \\\n        --manual-public-ip-logging-ok \\\n        --preferred-challenges dns \\\n        --server https://acme-v02.api.letsencrypt.org/directory \\\n        -d \"*.$SUB_DOMAIN.$DNS_DOMAIN\"\n    ```\n    You will see the following message:\n\n    ```\n    Please deploy a DNS TXT record under the name\n    _acme-challenge.rc2-test.kyma.online with the following value:\n\n    # TXT_VALUE\n\n    Before continuing, verify the record is deployed.\n    ```\n    Copy the `TXT_VALUE`.\n\n3. Open a new terminal and export these environment variables:\n    ```\n    export DNS_DOMAIN={YOUR_DOMAIN} # example.com\n    export SUB_DOMAIN={YOUR_SUBDOMAIN} # cluster (in this case the full name of your cluster is cluster.example.com)\n    export RS_GROUP={YOUR_RESOURCE_GROUP_NAME}\n    ```\n\n4. Export the `TXT_VALUE`.\n\n    ```\n    export TXT_VALUE={YOUR_TXT_VALUE}\n    ```\n    To modify TXT record for your domain, run:\n    ```\n    az network dns record-set txt delete -n \"_acme-challenge.$SUB_DOMAIN\" -g $RS_GROUP -z $DNS_DOMAIN --yes\n    az network dns record-set txt create -n \"_acme-challenge.$SUB_DOMAIN\" -g $RS_GROUP -z $DNS_DOMAIN --ttl 60 > /dev/null\n    az network dns record-set txt add-record -n \"_acme-challenge.$SUB_DOMAIN\" -g $RS_GROUP -z $DNS_DOMAIN --value $TXT_VALUE\n    ```\n5. Go back to the first console, wait about 2 minutes and press enter.\n\n6. Export the certificate and key as environment variables. Run these commands:\n\n    ```\n    export TLS_CERT=$(cat ./letsencrypt/live/$SUB_DOMAIN.$DNS_DOMAIN/fullchain.pem | base64 | sed 's/ /\\\\ /g')\n    export TLS_KEY=$(cat ./letsencrypt/live/$SUB_DOMAIN.$DNS_DOMAIN/privkey.pem | base64 | sed 's/ /\\\\ /g')\n    ```\n\n## Prepare the configuration file\n\nUse the GitHub release 0.8 or higher.\n\n1. Go to [this](https://github.com/kyma-project/kyma/releases/) page and choose the latest release.\n\n2. Export the release version as an environment variable. Run:\n    ```\n    export LATEST={KYMA_RELEASE_VERSION}\n    ```\n\n3. Download the `kyma-config-cluster.yaml` and `kyma-installer-cluster.yaml` files from the latest release. Run:\n   ```\n   wget https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-config-cluster.yaml\n   wget https://github.com/kyma-project/kyma/releases/download/$LATEST/kyma-installer-cluster.yaml\n   ```\n\n4. Prepare the deployment file.\n\n- Run this command:\n    ```\n    cat kyma-installer-cluster.yaml <(echo -e \"\\n---\") kyma-config-cluster.yaml | sed -e \"s/__PROXY_EXCLUDE_IP_RANGES__/10.0.0.1/g\" | sed -e \"s/__DOMAIN__/$SUB_DOMAIN.$DNS_DOMAIN/g\" | sed -e \"s/__TLS_CERT__/$TLS_CERT/g\" | sed -e \"s/__TLS_KEY__/$TLS_KEY/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n    ```\n\n- Alternatively, run this command if you deploy Kyma with Kubernetes version 1.14 and above:\n    ```\n    cat kyma-installer-cluster.yaml <(echo -e \"\\n---\") kyma-config-cluster.yaml | sed -e \"s/__PROMTAIL_CONFIG_NAME__/promtail-k8s-1-14.yaml/g\" | sed -e \"s/__PROXY_EXCLUDE_IP_RANGES__/10.0.0.1/g\" | sed -e \"s/__DOMAIN__/$SUB_DOMAIN.$DNS_DOMAIN/g\" | sed -e \"s/__TLS_CERT__/$TLS_CERT/g\" | sed -e \"s/__TLS_KEY__/$TLS_KEY/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n    ```\n\n5. The output of this operation is the `my_kyma.yaml` file. Use it to deploy Kyma on your GKE cluster.\n\n## Deploy Kyma\n\n1. Deploy Kyma using the `my-kyma` custom configuration file you created. Run:\n    ```\n    kubectl apply -f my-kyma.yaml\n    ```\n    >**NOTE:** If you get `Error from server (MethodNotAllowed)`, run the command again before proceeding to the next step.\n\n2. Check if the Pods of Tiller and the Kyma Installer are running:\n    ```\n    kubectl get pods --all-namespaces\n    ```\n\n3. Start Kyma installation:\n    ```\n    kubectl label installation/kyma-installation action=install\n    ```\n\n4. To watch the installation progress, run:\n    ```\n    while true; do \\\n      kubectl -n default get installation/kyma-installation -o jsonpath=\"{'Status: '}{.status.state}{', description: '}{.status.description}\"; echo; \\\n      sleep 5; \\\n    done\n    ```\n    After the installation process is finished, the `Status: Installed, description: Kyma installed` message appears.\n    In case of an error, you can fetch the logs from the Installer by running:\n    ```\n    kubectl -n kyma-installer logs -l 'name=kyma-installer'\n    ```\n\n## Configure DNS for the cluster load balancer\n\nRun these commands:\n\n```\nexport EXTERNAL_PUBLIC_IP=$(kubectl get service -n istio-system istio-ingressgateway -o jsonpath=\"{.status.loadBalancer.ingress[0].ip}\")\n\nexport REMOTE_ENV_IP=$(kubectl get service -n kyma-system application-connector-ingress-nginx-ingress-controller -o jsonpath=\"{.status.loadBalancer.ingress[0].ip}\")\n\nexport APISERVER_PUBLIC_IP=$(kubectl get service -n kyma-system apiserver-proxy-ssl -o jsonpath=\"{.status.loadBalancer.ingress[0].ip}\")\n\naz network dns record-set a create -g $RS_GROUP -z $DNS_DOMAIN -n \\*.$SUB_DOMAIN --ttl 60\naz network dns record-set a add-record -g $RS_GROUP -z $DNS_DOMAIN -n \\*.$SUB_DOMAIN -a $EXTERNAL_PUBLIC_IP\n\naz network dns record-set a create -g $RS_GROUP -z $DNS_DOMAIN -n gateway.$SUB_DOMAIN --ttl 60\naz network dns record-set a add-record -g $RS_GROUP -z $DNS_DOMAIN -n gateway.$SUB_DOMAIN -a $REMOTE_ENV_IP\n\naz network dns record-set a create -g $RS_GROUP -z $DNS_DOMAIN -n apiserver.$SUB_DOMAIN --ttl 60\naz network dns record-set a add-record -g $RS_GROUP -z $DNS_DOMAIN -n apiserver.$SUB_DOMAIN -a $APISERVER_PUBLIC_IP\n```\n\n## Access the cluster\n\n1. To get the address of the cluster's Console, check the host of the Console's virtual service. The name of the host of this virtual service corresponds to the Console URL. To get the virtual service host, run:\n\n```\nkubectl get virtualservice core-console -n kyma-system\n```\n\n2. Access your cluster under this address:\n\n```\nhttps://{VIRTUAL_SERVICE_HOST}\n```\n\n>**NOTE:** To log in to your cluster, use the default `admin` static user. To learn how to get the login details for this user, see [this](#installation-install-kyma-locally-access-the-kyma-console) document.\n\n</details>\n</div>\n","type":"Installation"},{"order":"04-05-use-your-own-image","title":"Use your own Kyma Installer image","source":"\nWhen you install Kyma from the release, you use the release artifacts that already contain the Kyma Installer - a Docker image containing the combined binary of the Installer and the component charts from the `/resources` folder.\nIf you install Kyma from sources and use the latest `master` branch, you must build the image yourself to prepare the configuration file for Kyma installation on a GKE or AKS cluster. You also require a new image if you add to the installation components and custom Helm charts that are not included in the `/resources` folder.\n\n>**NOTE:** Follow these steps both for your own and the `xip.io` default domain.\n\n1. Clone the repository using the `git clone https://github.com/kyma-project/kyma.git` command and navigate to the root folder.\n\n2. Build an image that is based on the current Installer image and includes the current installation and resources charts. Run:\n\n    ```\n    docker build -t kyma-installer -f tools/kyma-installer/kyma.Dockerfile .\n    ```\n\n3. Push the image to your Docker Hub. Run:\n    ```\n    docker tag kyma-installer:latest {YOUR_DOCKER_LOGIN}/kyma-installer\n    docker push {YOUR_DOCKER_LOGIN}/kyma-installer\n    ```\n\n4. Prepare the deployment file.\n\n<div tabs>\n  <details>\n  <summary>\n  GKE - xip.io\n  </summary>\n\n\nRun this command:\n\n```\n(cat installation/resources/installer.yaml ; echo \"---\" ; cat installation/resources/installer-config-cluster.yaml.tpl ; echo \"---\" ; cat installation/resources/installer-cr-cluster.yaml.tpl) | sed -e \"s/__.*__//g\" > my-kyma.yaml\n```\n\nAlternatively, run this command if you deploy Kyma with GKE version 1.12.6-gke.X and above:\n\n```\n(cat installation/resources/installer.yaml ; echo \"---\" ; cat installation/resources/installer-config-cluster.yaml.tpl ; echo \"---\" ; cat installation/resources/installer-cr-cluster.yaml.tpl) | sed -e \"s/__PROMTAIL_CONFIG_NAME__/promtail-k8s-1-14.yaml/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n```\n\n  </details>\n  <details>\n  <summary>\n  GKE - own domain\n  </summary>\n\n\nRun this command:\n\n```\n(cat installation/resources/installer.yaml ; echo \"---\" ; cat installation/resources/installer-config-cluster.yaml.tpl ; echo \"---\" ; cat installation/resources/installer-cr-cluster.yaml.tpl) | sed -e \"s/__DOMAIN__/$DOMAIN/g\" |sed -e \"s/__TLS_CERT__/$TLS_CERT/g\" | sed -e \"s/__TLS_KEY__/$TLS_KEY/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n```\n\nAlternatively, run this command if you deploy Kyma with GKE version 1.12.6-gke.X and above:\n\n```\n(cat installation/resources/installer.yaml ; echo \"---\" ; cat installation/resources/installer-config-cluster.yaml.tpl ; echo \"---\" ; cat installation/resources/installer-cr-cluster.yaml.tpl) | sed -e \"s/__PROMTAIL_CONFIG_NAME__/promtail-k8s-1-14.yaml/g\" | sed -e \"s/__DOMAIN__/$DOMAIN/g\" |sed -e \"s/__TLS_CERT__/$TLS_CERT/g\" | sed -e \"s/__TLS_KEY__/$TLS_KEY/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n```\n\n\n  </details>\n  <details>\n  <summary>\n  AKS - xip.io\n  </summary>\n\n\nRun this command:\n\n```\n(cat installation/resources/installer.yaml ; echo \"\\n---\" ; cat installation/resources/installer-config-cluster.yaml.tpl ; echo \"\\n---\" ; cat installation/resources/installer-cr-cluster.yaml.tpl) | sed -e \"s/__PROXY_EXCLUDE_IP_RANGES__/10.0.0.1/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n```\n\nAlternatively, run this command if you deploy Kyma with Kubernetes version 1.14 and above:\n\n```\n(cat installation/resources/installer.yaml ; echo \"\\n---\" ; cat installation/resources/installer-config-cluster.yaml.tpl ; echo \"\\n---\" ; cat installation/resources/installer-cr-cluster.yaml.tpl) | sed -e \"s/__PROMTAIL_CONFIG_NAME__/promtail-k8s-1-14.yaml/g\" | sed -e \"s/__PROXY_EXCLUDE_IP_RANGES__/10.0.0.1/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n```\n\n  </details>\n  <details>\n  <summary>\n  AKS - own domain\n  </summary>\n\n\nRun this command:\n\n```\n(cat installation/resources/installer.yaml ; echo \"\\n---\" ; cat installation/resources/installer-config-cluster.yaml.tpl ; echo \"\\n---\" ; cat installation/resources/installer-cr-cluster.yaml.tpl) | sed -e \"s/__PROXY_EXCLUDE_IP_RANGES__/10.0.0.1/g\" | sed -e \"s/__DOMAIN__/$SUB_DOMAIN.$DNS_DOMAIN/g\" | sed -e \"s/__TLS_CERT__/$TLS_CERT/g\" | sed -e \"s/__TLS_KEY__/$TLS_KEY/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n```\n\nAlternatively, run this command if you deploy Kyma with Kubernetes version 1.14 and above:\n\n```\n(cat installation/resources/installer.yaml ; echo \"\\n---\" ; cat installation/resources/installer-config-cluster.yaml.tpl ; echo \"\\n---\" ; cat installation/resources/installer-cr-cluster.yaml.tpl) | sed -e \"s/__PROMTAIL_CONFIG_NAME__/promtail-k8s-1-14.yaml/g\" | sed -e \"s/__PROXY_EXCLUDE_IP_RANGES__/10.0.0.1/g\" | sed -e \"s/__DOMAIN__/$SUB_DOMAIN.$DNS_DOMAIN/g\" | sed -e \"s/__TLS_CERT__/$TLS_CERT/g\" | sed -e \"s/__TLS_KEY__/$TLS_KEY/g\" | sed -e \"s/__.*__//g\" > my-kyma.yaml\n```\n\n\n  </details>\n</div>\n\n5. The output of this operation is the `my_kyma.yaml` file. Modify it to fetch the proper image with the changes you made ({YOUR_DOCKER_LOGIN}/kyma-installer). Use the modified file to deploy Kyma on your GKE cluster.\n","type":"Installation"},{"order":"04-06-use-helm","title":"Use Helm","source":"\nYou can use Helm to manage Kubernetes resources in Kyma, for example to check the already installed Kyma charts or to install new charts that are not included in the Kyma Installer image.\n\nTo use it, you must establish a secure connection with Tiller by saving the cluster's client certificate, key, and Certificate Authority (CA) to [Helm Home](https://helm.sh/docs/glossary/#helm-home-helm-home).\n\n>**NOTE:** Read [this](/docs/master/components/security/#details-tls-in-tiller) document to learn more about TLS in Tiller.\n\nRun these commands at the end of the Kyma cluster installation to save the client certificate, key, and CA to [Helm Home](https://helm.sh/docs/glossary/#helm-home-helm-home):\n\n```bash\nkubectl get -n kyma-installer secret helm-secret -o jsonpath=\"{.data['global\\.helm\\.ca\\.crt']}\" | base64 --decode > \"$(helm home)/ca.pem\";\nkubectl get -n kyma-installer secret helm-secret -o jsonpath=\"{.data['global\\.helm\\.tls\\.crt']}\" | base64 --decode > \"$(helm home)/cert.pem\";\nkubectl get -n kyma-installer secret helm-secret -o jsonpath=\"{.data['global\\.helm\\.tls\\.key']}\" | base64 --decode > \"$(helm home)/key.pem\";\n```\n\nAdditionally, you must add the `--tls` flag to every Helm command you run.\n","type":"Installation"},{"order":"04-10-update","title":"Update Kyma","source":"\nThis guide describes how to update Kyma deployed locally or on a cluster.\n\n## Prerequisites\n\n- [Docker](https://www.docker.com/)\n- Access to a Docker Registry - only for cluster installation\n\n## Overview\n\nKyma consists of multiple components, installed as [Helm](https://github.com/helm/helm/tree/master/docs) releases.\n\nUpdate of an existing deployment can include:\n- Changes in charts\n- Changes in overrides\n- Adding new releases\n\nThe update procedure consists of three main steps:\n- Prepare the update\n- Update the Kyma Installer\n- Trigger the update process\n\nIn case of dependency conflicts or major changes between components versions, some updates may not be possible.\n\n> **CAUTION:** Currently Kyma doesn't support removing components as a part of the update process.\n\n## Prepare the update\n\n- If you update an existing component, make all required changes to the Helm charts of the component located in the [`resource`](https://github.com/kyma-project/kyma/tree/master/resources) directory.\n\n- If you add a new component to your Kyma deployment, add a top-level Helm chart for that component. Additionally, run this command to edit the Installation custom resource and add the new component to the installed components list:\n  ```\n  kubectl edit installation kyma-installation\n  ```\n\n> **NOTE:** Read [this](#custom-resource-installation) document to learn more about the Installation custom resource.\n\n\n- If you introduced changes in overrides, update the existing ConfigMaps and Secrets. Add new ConfigMaps and Secrets if required. See [this](#configuration-helm-overrides-for-kyma-installation) document for more information on overrides.\n\n## Perform the update\n\nIf your changes involve any modifications in the `/resources` folder that includes component chart configurations, perform the whole update process that includes updating the Kyma Installer and triggering the update. If you only modify installation artifacts, for example by adding or removing components in the installation files or adding or removing overrides in the configuration files, only trigger the update process.\n\nRead about each update step in the following sections.\n\n### Update the Kyma Installer on a local deployment\n\n- Build a new image for the Kyma Installer:  \n  ```\n  ./installation/scripts/build-kyma-installer.sh\n  ```  \n  > **NOTE:** If you started Kyma with the `run.sh` script with a `--vm-driver {value}` parameter, provide the same parameter to the `build-kyma-installer.sh` script.\n\n- Restart the Kyma Installer Pod:  \n  ```\n  kubectl delete pod -n kyma-installer {INSTALLER_POD_NAME}\n  ```\n\n### Update the Kyma Installer on a cluster deployment\n\n- Build a new image for the Kyma Installer:\n  ```\n  docker build -t {IMAGE_NAME}:{IMAGE_TAG} -f tools/kyma-installer/kyma.Dockerfile .\n  ```\n\n- Push the image to your Docker registry.\n\n- Redeploy the Kyma Installer Pod using the new image. Run this command to edit the Deployment configuration:\n  ```\n  kubectl edit deployment kyma-installer -n kyma-installer\n  ```\n  Change the `image` and `imagePullPolicy` attributes in this section:  \n    ```  \n         spec:\n           containers:\n           - image: <your_image_name>:<your_tag>\n             imagePullPolicy: Always\n    ```  \n> **NOTE:** If the desired image name and `imagePullPolicy` is already set in the deployment configuration, restart the Pod by running `kubectl delete pod -n kyma-installer {INSTALLER_POD_NAME}`.\n\n### Trigger the update process\n\nExecute the following command to trigger the update process:\n\n```\nkubectl label installation/kyma-installation action=install\n```\n","type":"Installation"},{"order":"04-11-local-reinstallation","title":"Reinstall Kyma","source":"\nThe custom scripts allow you to remove Kyma from a Minikube cluster and reinstall Kyma without removing the cluster.\n\n> **NOTE:** These scripts do not delete the cluster from your Minikube. This allows you to quickly reinstall Kyma.\n\n1. Use the `clean-up.sh` script to uninstall Kyma from the cluster. Run:\n  ```\n  scripts/clean-up.sh\n  ```\n\n2. Run this script to reinstall Kyma on an existing cluster:\n  ```\n  cmd/run.sh --skip-minikube-start\n  ```\n","type":"Installation"},{"order":"04-12-local-installation-scripts","title":"Local installation scripts deep-dive","source":"\nThis document extends the [Install Kyma locally from sources](#installation-install-kyma-locally-from-sources) guide with a detailed breakdown of the alternative local installation method which is the `run.sh` script.\n\nThe following snippet is the main element of the `run.sh` script:\n\n```\nif [[ ! $SKIP_MINIKUBE_START ]]; then\n    bash $SCRIPTS_DIR/minikube.sh --domain \"$DOMAIN\" --vm-driver \"$VM_DRIVER\" $MINIKUBE_EXTRA_ARGS\nfi\n\nbash $SCRIPTS_DIR/build-kyma-installer.sh --vm-driver \"$VM_DRIVER\"\n\nif [ -z \"$CR_PATH\" ]; then\n\n    TMPDIR=`mktemp -d \"$CURRENT_DIR/../../temp-XXXXXXXXXX\"`\n    CR_PATH=\"$TMPDIR/installer-cr-local.yaml\"\n    bash $SCRIPTS_DIR/create-cr.sh --output \"$CR_PATH\" --domain \"$DOMAIN\"\n\nfi\n\nbash $SCRIPTS_DIR/installer.sh --local --cr \"$CR_PATH\" --password \"$ADMIN_PASSWORD\"\nrm -rf $TMPDIR\n```\nSubsequent sections provide details of all involved subscripts, in the order in which the `run.sh` script triggers them.\n\n## The minikube.sh script\n\n> **NOTE:** To work with Kyma, use only the provided scripts and commands. Kyma does not work on a basic Minikube cluster that you can start using the `minikube start` command.\n\nThe purpose of the `installation/scripts/minikube.sh` script is to configure and start Minikube. The script also checks if your development environment is configured to handle the Kyma installation. This includes checking Minikube and kubectl versions.\n\nIf Minikube is already initialized, the system prompts you to agree to remove the previous Minikube cluster.\n- If you plan to perform a clean installation, answer `yes`.\n- If you installed Kyma to your Minikube cluster and then stopped the cluster using the `minikube stop` command, answer `no`.  This allows you to start the cluster again without reinstalling Kyma.\n\nMinikube is configured to disable the default Nginx Ingress Controller.\n\n>**NOTE:** For the complete list of parameters passed to the `minikube start` command, refer to the `installation/scripts/minikube.sh` script.\n\nOnce Minikube is up and running, the script adds local installation entries to `/etc/hosts`.\n\n## The build-kyma-installer.sh script\n\nThe Kyma Installer is an application based on the [Kubernetes operator](https://coreos.com/operators/). Its purpose is to install Helm charts defined in the Installation custom resource. The Kyma Installer is a Docker image that bundles the Installer binary with Kyma charts.\n\nThe `installation/scripts/build-kyma-installer.sh` script extracts the Kyma-Installer image name from the `installer.yaml` deployment file and uses it to build a Docker image inside Minikube. This image contains local Kyma sources from the `resources` folder.\n\n>**NOTE:** For the Kyma Installer Docker image details, refer to the `tools/kyma-installer/kyma.Dockerfile` file.\n\n## The create-cr.sh script\n\nThe `installation/scripts/create-cr.sh` script prepares the Installation custom resource from the `installation/resources/installer-cr.yaml.tpl` template. The local installation scenario uses the default Installation custom resource. The Kyma Installer already contains local Kyma resources bundled, thus `url` is ignored by the Installer component.\n\n>**NOTE:** Read [this](#custom-resource-installation) document to learn more about the Installation custom resource.\n\n## The installer.sh script\n\nThe `installation/scripts/installer.sh` script creates the default RBAC role, installs [Tiller](https://docs.helm.sh/), and deploys the Kyma Installer component.\n\n>**NOTE:** For the Kyma Installer deployment details, refer to the `installation/resources/installer.yaml` file.\n\nThe script applies the Installation custom resource and marks it with the `action=install` label, which triggers the Kyma installation.\n\nIn the process of installing Tiller, a set of TLS certificates is created and saved to [Helm Home](https://helm.sh/docs/glossary/#helm-home-helm-home) to secure the connection between the client and the server.\n\n>**NOTE:** The Kyma installation runs in the background. Execute the `./installation/scripts/is-installed.sh` script to follow the installation process.\n\n## The is-installed.sh script\n\nThe `installation/scripts/is-installed.sh` script shows the status of Kyma installation in real time. The script checks the status of the Installation custom resource. When it detects that the status changed to `Installed`, the script exits. If you define a timeout period and the status doesn't change to `Installed` within that period, the script fetches the Installer logs. If you don't set a timeout period, the script waits for the change of the status until you terminate it.\n","type":"Installation"},{"order":"05-01-overview","title":"Overview","source":"\n## Default settings\n\nDuring installation, the Installer applies onto a cluster or Minikube all components defined in the `installer-cr-cluster.yaml.tpl` or `installer-cr.yaml.tpl` templates with their configuration defined in `values.yaml` files. It also imports the configuration overrides defined in the `installer-config-cluster.yaml.tpl` and `installer-config-local.yaml.tpl` templates located under the `installation/resources` subfolder.\n\n> **NOTE:** The installation and configuration templates serve as the basis for creating the installation (`kyma-installer-local.yaml` and `kyma-installer-cluster.yaml`) and configuration (`kyma-config-local.yaml` and `kyma-config-cluster.yaml`) release artifacts.\n\nBoth configuration files contain pre-defined overrides in the form of Secrets and ConfigMaps that the Installer uses during installation to replace default values specified in `values.yaml` files or to provide required configuration values. While the local configuration file contains hardcoded override values, the cluster configuration file is based on placeholders replaced with real values during installation.\nYou can add multiple Secrets and ConfigMaps for one component. If you duplicate the same parameter in a few Secrets or ConfigMaps for a given component but give it different values, the Installer accepts the last value in the file.\n\n>**CAUTION:** Both `values.yaml` and configuration files contain tested and recommended production settings. Note that you modify them on your own risk.\n\n## Installation configuration\n\nBefore you start the Kyma installation process, you can customize the default settings in installation and configuration files.\n\n### Components\n\nOne of the installation artifacts is the Kyma Installer image that contains all component charts located in the `kyma/resources` folder. Both cluster and local installation files contain a full list of these component names and their Namespaces.\nComponents that are not an integral part of the default Kyma Lite package are preceded with hashtags (#). It means that the Installer skips them during installation.   \nYou can customize component installation files by:\n- Removing hashtags in front of the component entries to enable a component installation.\n- Adding hashtags to disable a component installation.\n- Adding new components to the list along with their chart definition in the `kyma/resources` folder. In that case you must create your own [Kyma Installer image](#installation-use-your-own-kyma-installer-image) as you are adding new chart configuration.\n\nFor more details on custom component installation, see [this](#configuration-custom-component-installation) document.\n\n### Overrides\n\nThe configuration files provide production-ready settings for the Installer. These include ConfigMaps and Secrets with the overrides for the values hardcoded in the `values.yaml` files of component charts.\n\nYou can modify local settings, such as memory limits for a given resource, by changing values in the existing ConfigMaps and Secrets or adding new ones. Every ConfigMap and Secret that the Installer reads must contain [obligatory labels](#configuration-helm-overrides-for-kyma-installation-user-defined-overrides).\n\n[Read more](#configuration-helm-overrides-for-kyma-installation) about the types of overrides and the rules for creating them.\n\n## Runtime configuration\n\nOnce Kyma installation completes, you can still modify the installation artifacts. However, for these changes to take effect, you must trigger the update process:  \n\n```\nkubectl label installation/kyma-installation action=install\n```\n\n>**NOTE:** You cannot uninstall a Kyma component that is already installed. If you remove it from any of the installation files or add hashtags in front of its `name` and `namespace` entries, you only disable its further updates.\n\nApart from modifying the installation artifacts, you can use ConfigMaps and Secrets to configure the installed components and their behavior in the runtime.\n\nFor an example of such a runtime configuration, see [Helm Broker configuration](/docs/master/components/helm-broker/#configuration-configuration) in which you add links to the bundle repositories to a ConfigMap and label it with the `helm-broker-repo=true` label for the Helm Broker to expose additional Service Classes in the Service Catalog.\n\n## Advanced configuration\n\nAll `values.yaml` files in charts and sub-charts contain pre-defined attributes that are:\n- Configurable\n- Used in chart templates\n- Recommended production settings\n\nYou can only override values that are included in the `values.yaml` files of a given resource. If you want to extend the available customization options, request adding a new attribute with a default value to the pre-defined list in `values.yaml`. Raise a pull request in which you propose changes in the chart, the new attribute, and its value to be added to `values.yaml`. This way you ensure that you can override these values when needed, without these values being overwritten each time an update or rebase takes place.\n\n>**NOTE:** Avoid modifications of such open-source components as Istio or Service Catalog as such changes can severely impact their future version updates.\n","type":"Configuration"},{"order":"05-02-custom-component-installation","title":"Custom component installation","source":"\nBy default, you install Kyma with a set of components provided in the [**Kyma Lite**](#installation-overview) package.\n\nDuring installation, the Installer applies the content of the local or cluster installation file that includes the list of component names and Namespaces in which the components are installed. The Installer skips the lines starting with a hashtag (#):\n\n```\n#- name: \"ark\"\n#  namespace: \"heptio-ark\"\n```\n\nYou can modify the component list as follows:\n\n- Add components to the installation file before the installation\n- Add components to the installation file after the installation\n- Remove components from the installation file before the installation\n\n>**NOTE:** Currently, it is not possible to remove a component that is already installed. If you remove it from the installation file or precede its entries with a hashtag (#) when Kyma is already installed, the Installer simply does not update this component during the update process but the component is not removed.\n\nEach modification requires an action from the Installer for the changes to take place:\n- If you make changes before the installation, proceed with the standard installation process to finish Kyma setup.\n- If you make changes after the installation, follow the [update process](#installation-update-kyma) to refresh the current setup.\n\nRead the subsections for details.\n\n## Add a component\n\nYou can add a component before and after installation.\n\n### Installation from the release\n\n1. Download the [newest version](https://github.com/kyma-project/kyma/releases) of Kyma.\n2. Customize the installation by adding a component to the list in the installation file or removing hashtags (#) in front of the `name` and `namespace` entries. For example, to enable the Monitoring installation, add or unmark these entries:\n    ```\n    - name: \"monitoring\"\n      namespace: \"kyma-system\"\n    ```\n  * in the `kyma-installer-local.yaml` file for the **local** installation\n  * in the `kyma-installer-cluster.yaml` file for the **cluster** installation\n\n3. Follow the installation steps to [install Kyma locally from the release](#installation-install-kyma-locally) or [install Kyma on a cluster](#installation-install-kyma-on-a-cluster).\n\n### Installation from sources\n\n1. Customize the installation by adding a component to the list of components or removing hashtags (#) in front of the `name` and `namespace` entries in the following installation files:\n  * [`installer-cr.yaml.tpl`](https://github.com/kyma-project/kyma/blob/master/installation/resources/installer-cr.yaml.tpl) for the **local** installation\n  *  [`installer-cr-cluster.yaml.tpl`](https://github.com/kyma-project/kyma/blob/master/installation/resources/installer-cr-cluster.yaml.tpl) for the **cluster** installation\n\n2. Follow the installation steps to [install Kyma locally from sources](#installation-install-kyma-locally) or [install Kyma on a cluster](#installation-install-kyma-on-a-cluster).\n\n### Post-installation changes\n\nTo add a component that was not installed with Kyma by default, modify the Installation custom resource.\n\n1. Edit the resource:\n    ```\n    kubectl edit installation kyma-installation\n    ```\n2. Add the new component to the list of components or remove hashtags (#) preceding these lines:\n    ```\n    #- name: \"jaeger\"\n    #  namespace: \"kyma-system\"\n    ```\n3. Trigger the installation:\n\n   ```\n   kubectl label installation/kyma-installation action=install\n   ```\n\n### Verify the installation\n\nYou can verify the installation status by calling `./installation/scripts/is-installed.sh` in the terminal.\n\n## Remove a component\n\nYou can only remove the component before the installation process starts. To disable a component on the list of components that you install with Kyma by default, remove this component's `name` and `namespace` entries from the appropriate installation file or add hashtags (#) in front of them. The file differs depending on whether you install Kyma from the release or from sources, and if you install Kyma locally or on a cluster. The version of your component's deployment must match the version that Kyma currently supports.\n\n>**NOTE:** For some components, you must perform additional actions to remove them from the Kyma installation. In case of Istio and the Service Catalog, you must provide your own deployment of these components in the Kyma-supported version before you remove them from the installation process. See [this](https://github.com/kyma-project/kyma/blob/master/resources/istio-kyma-patch/templates/job.yaml#L25) file to check the currently supported version of Istio. See [this](https://github.com/kyma-project/kyma/blob/master/resources/service-catalog/charts/catalog/values.yaml#L3) file to check the currently supported version of the Service Catalog.\n\n### Installation from the release\n\n1. Download the [newest version](https://github.com/kyma-project/kyma/releases) of Kyma.\n2. Customize the installation by removing a component from the list in the installation file or adding hashtags (#) in front of the `name` and `namespace` entries. For example, to disable the Application Connector installation, remove these entries or add hashtags (#) in front of:\n    ```\n    - name: \"application-connector\"\n    namespace: \"kyma-system\"\n    ```\n  * in the `kyma-installer-local.yaml` file for the **local** installation\n  * in the `kyma-installer-cluster.yaml` file for the **cluster** installation\n\n3. Follow the installation steps to [install Kyma locally from the release](#installation-install-kyma-locally) or [install Kyma on a cluster](#installation-install-kyma-on-a-cluster).\n\n### Installation from sources\n\n1. Customize the installation by removing a component from the list of components or adding hashtags (#) in front of the `name` and `namespace` entries in the following installation files:\n  * [`installer-cr.yaml.tpl`](https://github.com/kyma-project/kyma/blob/master/installation/resources/installer-cr.yaml.tpl) for the **local** installation\n  *  [`installer-cr-cluster.yaml.tpl`](https://github.com/kyma-project/kyma/blob/master/installation/resources/installer-cr-cluster.yaml.tpl) for the **cluster** installation\n\n2. Follow the installation steps to [install Kyma locally from sources](#installation-install-kyma-locally) or [install Kyma on a cluster](#installation-install-kyma-on-a-cluster).\n\n### Verify the installation\n\n1. Check if all Pods are running in the `kyma-system` Namespace:\n  ```\n  kubectl get pods -n kyma-system\n  ```\n2. Sign in to the Kyma Console using the `admin@kyma.cx` email address as described in the [Install Kyma locally from the release](#installation-install-kyma-locally) document.\n","type":"Configuration"},{"order":"05-03-overrides","title":"Helm overrides for Kyma installation","source":"\nKyma packages its components into [Helm](https://github.com/helm/helm/tree/master/docs) charts that the [Installer](https://github.com/kyma-project/kyma/tree/master/components/installer) uses during installation and updates.\nThis document describes how to configure the Installer with new values for Helm [charts](https://github.com/helm/helm/blob/master/docs/charts.md) to override the default settings in `values.yaml` files.\n\n## Overview\n\nThe Installer is a [Kubernetes Operator](https://coreos.com/operators/) that uses Helm to install Kyma components.\nHelm provides an **overrides** feature to customize the installation of charts, for example to configure environment-specific values.\nWhen using Installer for Kyma installation, users can't interact with Helm directly. The installation is not an interactive process.\n\nTo customize the Kyma installation, the Installer exposes a generic mechanism to configure Helm overrides called **user-defined** overrides.\n\n## User-defined overrides\n\nThe Installer finds user-defined overrides by reading the ConfigMaps and Secrets deployed in the `kyma-installer` Namespace and marked with:\n- the `installer: overrides` label\n- a `component: {COMPONENT_NAME}` label if the override refers to a specific component\n\n>**NOTE:** There is also an additional `kyma-project.io/installation: \"\"` label in all ConfigMaps and Secrets that allows you to easily filter the installation resources.\n\nThe Installer constructs a single override by inspecting the ConfigMap or Secret entry key name. The key name should be a dot-separated sequence of strings corresponding to the structure of keys in the chart's `values.yaml` file or the entry in chart's template.\n\nThe Installer merges all overrides recursively into a single `yaml` stream and passes it to Helm during the Kyma installation and upgrade operations.\n\n## Common vs. component overrides\n\nThe Installer looks for available overrides each time a component installation or an update operation is due.\nOverrides for a component are composed of two sets: **common** overrides and **component-specific** overrides.\n\nKyma uses common overrides for the installation of all components. ConfigMaps and Secrets marked with the `installer: overrides` label contain the definition.\n\nKyma uses component-specific overrides only for the installation of specific components. ConfigMaps and Secrets marked with both `installer: overrides` and `component: {component-name}` labels contain the definition. Component-specific overrides have precedence over common ones in case of conflicting entries.\n\n>**NOTE:** Add the additional `kyma-project.io/installation: \"\"` label to both common and component-specific overrides to enable easy installation resources filtering.\n\n## Overrides examples\n\n### Top-level charts overrides\n\nOverrides for top-level charts are straightforward. Just use the template value from the chart as the entry key in the ConfigMap or Secret. Leave out the `.Values.` prefix.\n\nSe an example:\n\nThe Installer uses an `asset-store` top-level chart that contains a template with the following value reference:\n\n```\nresources: {{ toYaml .Values.resources | indent 12 }}\n```\n\nThe chart's default values `minio.resources.limits.memory` and `minio.resources.limits.cpu` in the `values.yaml` file resolve the template.\nThe following fragment of `values.yaml` shows this definition:\n```\nminio:\n  resources:\n    limits:\n      memory: \"128Mi\"\n      cpu: \"100m\"\n```\n\nTo override these values, for example to `512Mi` and `250m`, proceed as follows:\n- Create a ConfigMap in the `kyma-installer` Namespace and label it.\n- Add the `minio.resources.limits.memory: 512Mi` and `minio.resources.limits.cpu: 250m` entries to the ConfigMap and apply it:\n\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: assetstore-overrides\n  namespace: kyma-installer\n  labels:\n    installer: overrides\n    component: assetstore\n    kyma-project.io/installation: \"\"\ndata:\n  minio.resources.limits.memory: 512Mi #increased from 128Mi\n  minio.resources.limits.cpu: 250m #increased from 100m\nEOF\n```\n\nOnce the installation starts, the Installer generates overrides based on the ConfigMap entries. The system uses the values of `512Mi` instead of the default `128Mi` for Minio memory and `250m` instead of `100m` for Minio CPU from the chart's `values.yaml` file.\n\nFor overrides that the system should keep in Secrets, just define a Secret object instead of a ConfigMap with the same key and a base64-encoded value. Be sure to label the Secret.\n\nIf you add the overrides in the runtime, trigger the update process using this command:\n\n```\nkubectl label installation/kyma-installation action=install\n```\n\n### Sub-chart overrides\n\nOverrides for sub-charts follow the same convention as top-level charts. However, overrides require additional information about sub-chart location.\n\nWhen a sub-chart contains the `values.yaml` file, the information about the chart location is not necessary because the chart and it's `values.yaml` file are on the same level in the directory hierarchy.\n\nThe situation is different when the Installer installs a chart with sub-charts.\nAll template values for a sub-chart must be prefixed with a sub-chart \"path\" that is relative to the top-level \"parent\" chart.\n\nThis is not an Installer-specific requirement. The same considerations apply when you provide overrides manually using the `helm` command-line tool.\n\nHere is an example.\nThere's a `core` top-level chart that the Installer installs.\nThere's an `application-connector` sub-chart in `core` with a nested `connector-service` sub-chart.\nIn one of its templates, there's a following fragment:\n\n```\nspec:\n  containers:\n  - name: {{ .Chart.Name }}\n\targs:\n\t  - \"/connectorservice\"\n\t  - '--appName={{ .Chart.Name }}'\n\t  - \"--domainName={{ .Values.global.domainName }}\"\n\t  - \"--tokenExpirationMinutes={{ .Values.deployment.args.tokenExpirationMinutes }}\"\n```\n\nThis fragment of the `values.yaml` file in the `connector-service` chart defines the default value for `tokenExpirationMinutes`:\n\n```\ndeployment:\n  args:\n    tokenExpirationMinutes: 60\n```\n\nTo override this value, and change it from `60` to `90`, do the following:\n\n- Create a ConfigMap in the `kyma-installer` Namespace and label it.\n- Add the `application-connector.connector-service.deployment.args.tokenExpirationMinutes: 90` entry to the ConfigMap.\n\nNotice that the user-provided override key now contains two parts:\n\n- The chart \"path\" inside the top-level `core` chart called `application-connector.connector-service`\n- The original template value reference from the chart without the `.Values.` prefix, `deployment.args.tokenExpirationMinutes`.\n\nOnce the installation starts, the Installer generates overrides based on the ConfigMap entries. The system uses the value of `90` instead of the default value of `60` from the `values.yaml` chart file.\n\n\n## Global overrides\n\nThere are several important parameters usually shared across the charts.\nHelm convention to provide these requires the use of the `global` override key.\nFor example, to define the `global.domain` override, just use `global.domain` as the name of the key in a ConfigMap or Secret for the Installer.\n\nOnce the installation starts, the Installer merges all of the ConfigMap entries and collects all of the global entries under the `global` top-level key to use for the installation.\n\n\n## Values and types\n\nThe Installer generally recognizes all override values as strings. It internally renders overrides to Helm as a `yaml` stream with only string values.\n\nThere is one exception to this rule with respect to handling booleans:\nThe system converts `true` or `false` strings that it encounters to a corresponding boolean `true` or `false` value.\n\n\n## Merging and conflicting entries\n\nWhen the Installer encounters two overrides with the same key prefix, it tries to merge them.\nIf both of them represent a ConfigMap (they have nested sub-keys), their nested keys are recursively merged.\nIf at least one of keys points to a final value, the Installer performs the merge in a non-deterministic order, so either one of the overrides is rendered in the final `yaml` data.\n\nIt is important to avoid overrides having the same keys for final values.\n\n\n### Non-conflicting merge example\n\nTwo overrides with a common key prefix (\"a.b\"):\n\n```\n\"a.b.c\": \"first\"\n\"a.b.d\": \"second\"\n```\n\nThe Installer yields the correct output:\n\n```\na:\n  b:\n    c: first\n    d: second\n```\n\n### Conflicting merge example\n\nTwo overrides with the same key (\"a.b\"):\n\n```\n\"a.b\": \"first\"\n\"a.b\": \"second\"\n```\n\nThe Installer yields either:\n\n```\na:\n  b: \"first\"\n```\n\nOr (due to non-deterministic merge order):\n\n```\na:\n  b: \"second\"\n```\n","type":"Configuration"},{"order":"06-01-installation","title":"Installation","source":"\nThe `installations.installer.kyma-project.io` CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to control the Kyma Installer, a proprietary solution based on the\n[Kubernetes operator](https://coreos.com/operators/) principles. To get the up-to-date CRD and show the output in the `yaml` format, run this command:  \n\n```\nkubectl get crd installations.installer.kyma-project.io -o yaml\n```\n\n## Sample custom resource\n\nThis is a sample CR that controls the Kyma Installer. This example has the **action** label set to `install`, which means that it triggers the installation of Kyma. The  **name** and **namespace**  fields in the `components` array define which components you install and Namespaces in which you install them.\n\n>**NOTE:** See the `installer-cr.yaml.tpl` file in the `/installation/resources` directory for the complete list of Kyma components.\n\n```\napiVersion: \"installer.kyma-project.io/v1alpha1\"\nkind: Installation\nmetadata:\n  name: kyma-installation\n  labels:\n    action: install\n  finalizers:\n    - finalizer.installer.kyma-project.io\nspec:\n  version: \"1.0.0\"\n  url: \"https://sample.url.com/kyma_release.tar.gz\"\n  components:\n    - name: \"cluster-essentials\"\n      namespace: \"kyma-system\"\n    - name: \"istio\"\n      namespace: \"istio-system\"\n    - name: \"prometheus-operator\"\n      namespace: \"kyma-system\"\n    - name: \"provision-bundles\"\n    - name: \"dex\"\n      namespace: \"kyma-system\"\n    - name: \"core\"\n      namespace: \"kyma-system\"\n```\n\n## Custom resource parameters\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n| Field   |      Mandatory      |  Description |\n|----------|:-------------:|:------|\n| **metadata.name** | **YES** | Specifies the name of the CR. |\n| **metadata.labels.action** | **YES** | Defines the behavior of the Kyma Installer. Available options are `install` and `uninstall`. |\n| **metadata.finalizers** | **NO** | Protects the CR from deletion. Read [this](https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#finalizers) Kubernetes document to learn more about finalizers. |\n| **spec.version** | **NO** | When manually installing Kyma on a cluster, specify any valid [SemVer](https://semver.org/) notation string. |\n| **spec.url** | **YES** | Specifies the location of the Kyma sources `tar.gz` package. For example, for the `master` branch of Kyma, the address is `https://github.com/kyma-project/kyma/archive/master.tar.gz` |\n| **spec.components** | **YES** | Lists which components of Helm chart components to install or update. |\n| **spec.components.name** | **YES** | Specifies the name of the component which is the same as the name of the component subdirectory in the `resources` directory. |\n| **spec.components.namespace** | **YES** | Defines the Namespace in which you want the Installer to install, or update the component. |\n| **spec.components.release** | **NO** | Provides the name of the Helm release. The default parameter is the component name. |\n\n## Additional information\n\nThe Kyma Installer adds the **status** section which describes the status of Kyma installation. This table lists the fields of the **status** section.\n\n| Field   |      Mandatory      |  Description |\n|----------|:-------------:|:------|\n| **status.state** | **YES** | Describes the installation state. Takes one of four values. |\n| **status.description** | **YES** | Describes the installation step the installer performs at the moment. |\n| **status.errorLog** | **YES** | Lists all errors that happen during installation. |\n| **status.errorLog.component** | **YES** | Specifies the name of the component that causes the error. |\n| **status.errorLog.log** | **YES** | Provides a description of the error. |\n| **status.errorLog.occurrences** | **YES** | Specifies the number of subsequent occurrences of the error. |\n\nThe **status.state** field uses one of the following four values to describe the installation state:\n\n|   State   |  Description |\n|----------|:-------------|\n| **Installed** | Installation successful. |\n| **Uninstalled** | Uninstallation successful. |\n| **InProgress** | The Installer is still installing or uninstalling Kyma. No errors logged. |\n| **Error** | The Installer encountered a problem but it continues to try to process the resource. |\n\n## Related resources and components\n\nThese components use this CR:\n\n| Component   |   Description |\n|----------|:------|\n| Installer  |  The CR triggers the Installer to install, update or delete of the specified components. |\n","type":"Custom Resource"},{"order":"08-01-sample-service-deployment-to-local","title":"Sample service deployment on local","source":"\nThis tutorial is intended for the developers who want to quickly learn how to deploy a sample service and test it with Kyma installed locally on Mac.\n\nThis tutorial uses a standalone sample service written in the [Go](http://golang.org) language .\n\n## Prerequisites\n\nTo use the Kyma cluster and install the example, download these tools:\n\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.10.0\n- [curl](https://github.com/curl/curl)\n\n## Steps\n\n### Deploy and expose a sample standalone service\n\nFollow these steps:\n\n1. Deploy the sample service to any of your Namespaces. Use the `stage` Namespace for this guide:\n\n   ```bash\n   kubectl create -n stage -f https://raw.githubusercontent.com/kyma-project/examples/master/http-db-service/deployment/deployment.yaml\n   ```\n\n2. Create an unsecured API for your example service:\n\n   ```bash\n   kubectl apply -n stage -f https://raw.githubusercontent.com/kyma-project/examples/master/gateway/service/api-without-auth.yaml\n   ```\n\n3. Add the IP address of Minikube to the `hosts` file on your local machine for your APIs:\n\n   ```bash\n   $ echo \"$(minikube ip) http-db-service.kyma.local\" | sudo tee -a /etc/hosts\n   ```\n\n4. Access the service using the following call:\n   ```bash\n   curl -ik https://http-db-service.kyma.local/orders\n   ```\n\n   The system returns a response similar to the following:\n   ```\n   HTTP/2 200\n   content-type: application/json;charset=UTF-8\n   vary: Origin\n   date: Mon, 01 Jun 2018 00:00:00 GMT\n   content-length: 2\n   x-envoy-upstream-service-time: 131\n   server: envoy\n\n   []\n   ```\n\n### Update your service's API to secure it\n\nRun the following command:\n\n   ```bash\n   kubectl apply -n stage -f https://raw.githubusercontent.com/kyma-project/examples/master/gateway/service/api-with-auth.yaml\n   ```\nAfter you apply this update, you must include a valid bearer ID token in the Authorization header to access the service.\n\n>**NOTE:** The update might take some time.\n","type":"Tutorials"},{"order":"08-02-sample-service-deployment-to-cluster","title":"Sample service deployment on a cluster","source":"\nThis tutorial is intended for the developers who want to quickly learn how to deploy a sample service and test it with the Kyma cluster.\n\nThis tutorial uses a standalone sample service written in the [Go](http://golang.org) language.\n\n## Prerequisites\n\nTo use the Kyma cluster and install the example, download these tools:\n\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.10.0\n- [curl](https://github.com/curl/curl)\n\n## Steps\n\n### Get the kubeconfig file and configure the CLI\n\nFollow these steps to get the `kubeconfig` file and configure the CLI to connect to the cluster:\n\n1. Access the Console UI of your Kyma cluster.\n2. Click **Administration**.\n3. Click the **Download config** button to download the `kubeconfig` file to a selected location on your machine.\n4. Open a terminal window.\n5. Export the **KUBECONFIG** environment variable to point to the downloaded `kubeconfig`. Run this command:\n  ```\n  export KUBECONFIG={KUBECONFIG_FILE_PATH}\n  ```\n  >**NOTE:** Drag and drop the `kubeconfig` file in the terminal to easily add the path of the file to the `export KUBECONFIG` command you run.\n\n6. Run `kubectl cluster-info` to check if the CLI is connected to the correct cluster.\n\n### Set the cluster domain as an environment variable\n\nThe commands in this guide use URLs in which you must provide the domain of the cluster that you use.\nExport the domain of your cluster as an environment variable. Run:  \n  ```\n  export yourClusterDomain='{YOUR_CLUSTER_DOMAIN}'\n  ```\n\n### Deploy and expose a sample standalone service\n\nFollow these steps:\n\n1. Deploy the sample service to any of your Namespaces. Use the `stage` Namespace for this guide:\n\n   ```bash\n   kubectl create -n stage -f https://raw.githubusercontent.com/kyma-project/examples/master/http-db-service/deployment/deployment.yaml\n   ```\n\n2. Create an unsecured API for your service:\n\n   ```bash\n   curl -k https://raw.githubusercontent.com/kyma-project/examples/master/gateway/service/api-without-auth.yaml |  sed \"s/.kyma.local/.$yourClusterDomain/\" | kubectl apply -n stage -f -\n   ```\n\n3. Access the service using the following call:\n   ```bash\n   curl -ik https://http-db-service.$yourClusterDomain/orders\n   ```\n\n   The system returns a response similar to the following:\n   ```\n   HTTP/2 200\n   content-type: application/json;charset=UTF-8\n   vary: Origin\n   date: Mon, 01 Jun 2018 00:00:00 GMT\n   content-length: 2\n   x-envoy-upstream-service-time: 131\n   server: envoy\n\n   []\n   ```\n\n### Update your service's API to secure it\n\nRun the following command:\n\n   ```bash\n   curl -k https://raw.githubusercontent.com/kyma-project/examples/master/gateway/service/api-with-auth.yaml |  sed \"s/.kyma.local/.$yourClusterDomain/\" | kubectl apply -n stage -f -\n   ```\nAfter you apply this update, you must include a valid bearer ID token in the Authorization header to access the service.\n\n>**NOTE:** The update might take some time.\n","type":"Tutorials"},{"order":"08-03-local-develop-no-docker","title":"Develop a service locally without using Docker","source":"\nYou can develop services in the local Kyma installation without extensive Docker knowledge or a need to build and publish a Docker image. The `minikube mount` feature allows you to mount a directory from your local disk into the local Kubernetes cluster.\n\nThis tutorial shows how to use this feature, using the service example implemented in Golang.\n\n## Prerequisites\n\nInstall [Golang](https://golang.org/dl/).\n\n## Steps\n\n### Install the example on your local machine\n\n1. Install the example:\n```shell\ngo get -insecure github.com/kyma-project/examples/http-db-service\n```\n2. Navigate to installed example and the `http-db-service` folder inside it:\n```shell\ncd ~/go/src/github.com/kyma-project/examples/http-db-service\n```\n3. Build the executable to run the application:\n```shell\nCGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .\n```\n\n### Mount the example directory into Minikube\n\nFor this step, you need a running local Kyma instance. Read [this](#installation-install-kyma-locally-from-the-release) document to learn how to install Kyma locally.\n\n1. Open the terminal window. Do not close it until the development finishes.\n2. Mount your local drive into Minikube:\n```shell\n# Use the following pattern:\nminikube mount {LOCAL_DIR_PATH}:{CLUSTER_DIR_PATH}`\n# To follow this guide, call:\nminikube mount ~/go/src/github.com/kyma-project/examples/http-db-service:/go/src/github.com/kyma-project/examples/http-db-service\n```\n\nSee the example and expected result:\n```shell\n# Terminal 1\n$ minikube mount ~/go/src/github.com/kyma-project/examples/http-db-service:/go/src/github.com/kyma-project/examples/http-db-service\n\nMounting /Users/{USERNAME}/go/src/github.com/kyma-project/examples/http-db-service into /go/src/github.com/kyma-project/examples/http-db-service on the minikube VM\nThis daemon process must stay alive for the mount to still be accessible...\nufs starting\n```\n\n### Run your local service inside Minikube\n\n1. Create Pod that uses the base Golang image to run your executable located on your local machine:\n```shell\n# Terminal 2\nkubectl run mydevpod --image=golang:1.9.2-alpine --restart=Never -n stage --overrides='\n{\n   \"spec\":{\n      \"containers\":[\n         {\n            \"name\":\"mydevpod\",\n            \"image\":\"golang:1.9.2-alpine\",\n            \"command\": [\"./main\"],\n            \"workingDir\":\"/go/src/github.com/kyma-project/examples/http-db-service\",\n            \"volumeMounts\":[\n               {\n                  \"mountPath\":\"/go/src/github.com/kyma-project/examples/http-db-service\",\n                  \"name\":\"local-disk-mount\"\n               }\n            ]\n         }\n      ],\n      \"volumes\":[\n         {\n            \"name\":\"local-disk-mount\",\n            \"hostPath\":{\n               \"path\":\"/go/src/github.com/kyma-project/examples/http-db-service\"\n            }\n         }\n      ]\n   }\n}\n'\n```\n2. Expose the Pod as a service from Minikube to verify it:\n```shell\nkubectl expose pod mydevpod --name=mypodservice --port=8017 --type=NodePort -n stage\n```\n3. Check the Minikube IP address and Port, and use them to access your service.\n```shell\n# Get the IP address.\nminikube ip\n# See the example result: 192.168.64.44\n# Check the Port.\nkubectl get services -n stage\n# See the example result: mypodservice  NodePort 10.104.164.115  <none>  8017:32226/TCP  5m\n```\n4. Call the service from your terminal.\n```shell\ncurl {minikube ip}:{port}/orders -v\n# See the example: curl http://192.168.64.44:32226/orders -v\n# The command returns an empty array.\n```\n\n### Modify the code locally and see the results immediately in Minikube\n\n1. Edit the `main.go` file by adding a new `test` endpoint to the `startService` function\n```go\nrouter.HandleFunc(\"/test\", func (w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"test\"))\n})\n```\n2. Build a new executable to run the application inside Minikube:\n```shell\nCGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .\n```\n3. Replace the existing Pod with the new version:\n```shell\nkubectl get pod mydevpod -n stage -o yaml | kubectl replace --force -f -\n```\n4. Call the new `test` endpoint of the service from your terminal. The command returns the `Test` string:\n```shell\ncurl http://192.168.64.44:32226/test -v\n```\n","type":"Tutorials"},{"order":"08-04-publish-service-image-and-deploy","title":"Publish a service Docker image and deploy it to Kyma","source":"\nFollow this tutorial to learn how to develop a service locally. You can immediately see all the changes made in a local Kyma installation based on Minikube, without building a Docker image and publishing it to a Docker registry, such as the Docker Hub.\n\nUsing the same example service, this tutorial explains how to build a Docker image for your service, publish it to the Docker registry, and deploy it to the local Kyma installation. The instructions base on Minikube, but you can also use the image that you create and the Kubernetes resource definitions that you use on the Kyma cluster.\n\n>**NOTE:** The deployment works both on local Kyma installation and on the Kyma cluster.\n\n## Steps\n\n### Build a Docker image\n\nThe `http-db-service` example used in this guide provides you with the `Dockerfile` necessary for building Docker images. Examine the `Dockerfile` to learn how it looks and how it uses the Docker Multistaging feature, but do not use it one-to-one for production. There might be custom `LABEL` attributes with values to override.\n\n1. In your terminal, go to the `examples/http-db-service` directory. If you did not follow the [Sample service deployment on local](#tutorials-sample-service-deployment-on-local) guide and you do not have this directory locally, get the `http-db-service` example from the [`examples`](https://github.com/kyma-project/examples) repository.\n2. Run the build with `./build.sh`.\n\n>**NOTE:** Ensure that the new image builds and is available in your local Docker registry by calling `docker images`. Find an image called `example-http-db-service` and tagged as `latest`.\n\n### Register the image in the Docker Hub\n\nThis guide bases on Docker Hub. However, there are many other Docker registries available. You can use a private Docker registry, but it must be available in the Internet. For more details about using a private Docker registry, see the [this](#tutorials-publish-a-service-docker-image-and-deploy-it-to-kyma) document.\n\n1. Open the [Docker Hub](https://hub.docker.com/) webpage.\n2. Provide all of the required details and sign up.\n\n### Sign in to the Docker Hub registry in the terminal\n\n1. Call `docker login`.\n2. Provide the username and password, and select the `ENTER` key.\n\n### Push the image to the Docker Hub\n\n1. Tag the local image with a proper name required in the registry: `docker tag example-http-db-service {USERNAME}/example-http-db-service:0.0.1`.\n2. Push the image to the registry: `docker push {USERNAME}/example-http-db-service:0.0.1`.\n\n>**NOTE:** To verify if the image is successfully published, check if it is available online at the following address: `https://hub.docker.com/r/{USERNAME}/example-http-db-service/`\n\n### Deploy to Kyma\n\nThe `http-db-service` example contains sample Kubernetes resource definitions needed for the basic Kyma deployment. Find them in the `deployment` folder. Perform the following modifications to use your newly-published image in the local Kyma installation:\n\n1. Go to the `deployment` directory.\n2. Edit the `deployment.yaml` file. Change the **image** attribute to `{USERNAME}/example-http-db-service:0.0.1`.\n3. Create the new resources in local Kyma using these commands: `kubectl create -f deployment.yaml -n stage && kubectl create -f ingress.yaml -n stage`.\n4. Edit your `/etc/hosts` to add the new `http-db-service.kyma.local` host to the list of hosts associated with your `minikube ip`. Follow these steps:\n    - Open a terminal window and run: `sudo vim /etc/hosts`\n    - Select the **i** key to insert a new line at the top of the file.\n    - Add this line: `{YOUR.MINIKUBE.IP} http-db-service.kyma.local`\n    - Type `:wq` and select the **Enter** key to save the changes.\n5. Run this command to check if you can access the service: `curl https://http-db-service.kyma.local/orders`. The response should return an empty array.\n","type":"Tutorials"},{"order":"12-01-try-out-kyma","title":"Kyma features and concepts in practice","source":"\nThe table contains a list of examples that demonstrate Kyma functionalities. You can run all of them locally or on a cluster. Examples are organized by a feature or concept they showcase. Each of them contains ready-to-use code snippets and the instructions in `README.md` documents.\n\nFollow the links to examples' code and content sources, and try them on your own.\n\n| Example | Description | Technology |\n|---|---|---|\n| [HTTP DB Service](https://github.com/kyma-project/examples/blob/master/http-db-service/README.md) | Test the service that exposes an HTTP API to access a database on the cluster. | Go, MSSQL |\n| [Event Service Subscription](https://github.com/kyma-project/examples/blob/master/event-subscription/service/README.md) | Test the example that demonstrates the `publish` and `consume` features of the Event Bus. | Go |\n| [Event Lambda Subscription](https://github.com/kyma-project/examples/blob/master/event-subscription/lambda/README.md) | Create functions, trigger them on Events, and bind them to services.  | Kubeless |\n| [Gateway](https://github.com/kyma-project/examples/blob/master/gateway/README.md) | Expose APIs for functions or services.  | Kubeless |\n| [Service Binding](https://github.com/kyma-project/examples/blob/master/service-binding/lambda/README.md) | Bind a Redis service to a lambda function. | Kubeless, Redis, NodeJS |\n| [Alert Rules](https://github.com/kyma-project/examples/blob/master/monitoring-alert-rules/README.md) | Configure alert rules in Kyma.  | Prometheus |\n| [Custom Metrics in Kyma](https://github.com/kyma-project/examples/blob/master/monitoring-custom-metrics/README.md) | Expose custom metrics in Kyma.  | Go, Prometheus |\n| [Event Email Service](https://github.com/kyma-project/examples/blob/master/event-email-service/README.md) | Send an automated email upon receiving an Event.  | NodeJS |\n| [Tracing](https://github.com/kyma-project/examples/blob/master/tracing/README.md) | Configure tracing for a service in Kyma. | Go |\n","type":"Examples"}]},"navigation":{"topics":[{"id":"kyma","contentType":"root","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"In a nutshell","anchor":"in-a-nutshell"},{"name":"Main features","anchor":"main-features"},{"name":"Technology stack","anchor":"technology-stack"},{"name":"Key components","anchor":"key-components"},{"name":"Kyma and Knative - brothers in arms","anchor":"kyma-and-knative---brothers-in-arms"},{"name":"How to start","anchor":"how-to-start"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Components","anchor":"components"},{"name":"Namespaces","anchor":"namespaces"},{"name":"Testing Kyma","anchor":"testing-kyma"},{"name":"Charts","anchor":"charts"},{"name":"Deploy with a private Docker registry","anchor":"deploy-with-a-private-docker-registry"}]},{"topicType":"Installation","name":"Installation","anchor":"installation","titles":[{"name":"Overview","anchor":"overview"},{"name":"Install Kyma locally","anchor":"install-kyma-locally"},{"name":"Install Kyma on a cluster","anchor":"install-kyma-on-a-cluster"},{"name":"Use your own domain","anchor":"use-your-own-domain"},{"name":"Use your own Kyma Installer image","anchor":"use-your-own-kyma-installer-image"},{"name":"Use Helm","anchor":"use-helm"},{"name":"Update Kyma","anchor":"update-kyma"},{"name":"Reinstall Kyma","anchor":"reinstall-kyma"},{"name":"Local installation scripts deep-dive","anchor":"local-installation-scripts-deep-dive"}]},{"topicType":"Configuration","name":"Configuration","anchor":"configuration","titles":[{"name":"Overview","anchor":"overview"},{"name":"Custom component installation","anchor":"custom-component-installation"},{"name":"Helm overrides for Kyma installation","anchor":"helm-overrides-for-kyma-installation"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Installation","anchor":"installation"}]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Sample service deployment on local","anchor":"sample-service-deployment-on-local"},{"name":"Sample service deployment on a cluster","anchor":"sample-service-deployment-on-a-cluster"},{"name":"Develop a service locally without using Docker","anchor":"develop-a-service-locally-without-using-docker"},{"name":"Publish a service Docker image and deploy it to Kyma","anchor":"publish-a-service-docker-image-and-deploy-it-to-kyma"}]},{"topicType":"Examples","name":"Examples","anchor":"examples","titles":[{"name":"Kyma features and concepts in practice","anchor":"kyma-features-and-concepts-in-practice"}]}]},{"id":"security","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Kubeconfig generator","anchor":"kubeconfig-generator"},{"name":"GraphQL","anchor":"graphql"},{"name":"GraphQL request flow","anchor":"graphql-request-flow"},{"name":"TLS in Tiller","anchor":"tls-in-tiller"},{"name":"Roles in Kyma","anchor":"roles-in-kyma"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Group","anchor":"group"},{"name":"IDPPreset","anchor":"idppreset"}]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Update TLS certificate","anchor":"update-tls-certificate"},{"name":"Manage static users in Dex","anchor":"manage-static-users-in-dex"},{"name":"Add an Identity Provider to Dex","anchor":"add-an-identity-provider-to-dex"}]}]},{"id":"service-catalog","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Resources","anchor":"resources"},{"name":"Provisioning and binding","anchor":"provisioning-and-binding"},{"name":"Service Catalog backup and restore","anchor":"service-catalog-backup-and-restore"},{"name":"Experimental features","anchor":"experimental-features"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"ServiceBindingUsage","anchor":"servicebindingusage"},{"name":"UsageKind","anchor":"usagekind"}]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Register a broker in the Service Catalog","anchor":"register-a-broker-in-the-service-catalog"}]},{"topicType":"UI Contracts","name":"UI Contracts","anchor":"ui-contracts","titles":[{"name":"Overview","anchor":"overview"},{"name":"Catalog view","anchor":"catalog-view"},{"name":"Instances View","anchor":"instances-view"}]},{"topicType":"Service Brokers","name":"Service Brokers","anchor":"service-brokers","titles":[{"name":"Overview","anchor":"overview"},{"name":"GCP Broker","anchor":"gcp-broker"},{"name":"Azure Service Broker","anchor":"azure-service-broker"}]}]},{"id":"helm-broker","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Create a bundle","anchor":"create-a-bundle"},{"name":"Bind bundles","anchor":"bind-bundles"},{"name":"Create a bundles repository","anchor":"create-a-bundles-repository"},{"name":"Service Classes documentation provided by bundles","anchor":"service-classes-documentation-provided-by-bundles"}]},{"topicType":null,"name":"Configuration","anchor":"configuration","titles":[]}]},{"id":"application-connector","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Architecture","name":"Architecture","anchor":"architecture","titles":[{"name":"Application Connector components","anchor":"application-connector-components"},{"name":"Connector Service","anchor":"connector-service"},{"name":"Application Gateway","anchor":"application-gateway"},{"name":"Application Broker","anchor":"application-broker"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Security","anchor":"security"},{"name":"Access the Application Connector on a local Kyma deployment","anchor":"access-the-application-connector-on-a-local-kyma-deployment"},{"name":"Consume applications through the Service Catalog","anchor":"consume-applications-through-the-service-catalog"},{"name":"Application Registry","anchor":"application-registry"},{"name":"Pass an access token in a request header","anchor":"pass-an-access-token-in-a-request-header"},{"name":"Payload size limits for registering APIs","anchor":"payload-size-limits-for-registering-apis"},{"name":"API registration in the Application Registry","anchor":"api-registration-in-the-application-registry"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Application","anchor":"application"},{"name":"ApplicationMapping","anchor":"applicationmapping"},{"name":"EventActivation","anchor":"eventactivation"},{"name":"TokenRequest","anchor":"tokenrequest"}]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Create a new Application","anchor":"create-a-new-application"},{"name":"Get the client certificate","anchor":"get-the-client-certificate"},{"name":"Register a service","anchor":"register-a-service"},{"name":"Register a secured API","anchor":"register-a-secured-api"},{"name":"Trigger a lambda with events","anchor":"trigger-a-lambda-with-events"},{"name":"Call a registered external service from Kyma","anchor":"call-a-registered-external-service-from-kyma"},{"name":"Bind an Application to a Namespace","anchor":"bind-an-application-to-a-namespace"},{"name":"Renew the client certificate","anchor":"renew-the-client-certificate"},{"name":"Revoke the client certificate","anchor":"revoke-the-client-certificate"},{"name":"Rotate the Root CA certificate and key","anchor":"rotate-the-root-ca-certificate-and-key"}]},{"topicType":"API","name":"API","anchor":"api","titles":[{"name":"Connector Service","anchor":"connector-service"},{"name":"Application Registry","anchor":"application-registry"},{"name":"Event Service","anchor":"event-service"}]}]},{"id":"event-bus","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Basic concepts","anchor":"basic-concepts"},{"name":"Event flow requirements","anchor":"event-flow-requirements"},{"name":"Service Programming Model","anchor":"service-programming-model"},{"name":"Troubleshooting","anchor":"troubleshooting"},{"name":"Subscription updates","anchor":"subscription-updates"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Subscription","anchor":"subscription"}]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]}]},{"id":"service-mesh","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Sidecar Proxy Injection","anchor":"sidecar-proxy-injection"},{"name":"Istio patch","anchor":"istio-patch"},{"name":"Istio RBAC configuration","anchor":"istio-rbac-configuration"}]}]},{"id":"serverless","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Custom Resources","anchor":"custom-resources"},{"name":"Managing Lambdas","anchor":"managing-lambdas"},{"name":"The Node.js Runtime","anchor":"the-node.js-runtime"}]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]}]},{"id":"monitoring","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Expose custom metrics in Kyma","anchor":"expose-custom-metrics-in-kyma"}]}]},{"id":"tracing","contentType":"components","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"Overview","anchor":"overview"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Benefits of distributed tracing","anchor":"benefits-of-distributed-tracing"},{"name":"Jaeger","anchor":"jaeger"},{"name":"Propagate HTTP headers","anchor":"propagate-http-headers"},{"name":"Compare traces","anchor":"compare-traces"}]}]},{"id":"api-gateway","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Security","anchor":"security"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Api","anchor":"api"}]}]},{"id":"logging","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Access logs","anchor":"access-logs"},{"name":"Storage configuration","anchor":"storage-configuration"}]}]},{"id":"backup","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Configuration","anchor":"configuration"},{"name":"Back up a Kyma cluster","anchor":"back-up-a-kyma-cluster"},{"name":"Restore a Kyma cluster","anchor":"restore-a-kyma-cluster"}]}]},{"id":"console","contentType":"components","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"Overview","anchor":"overview"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"UI extensibility","anchor":"ui-extensibility"},{"name":"Console Backend Service","anchor":"console-backend-service"},{"name":"Security guidelines for MicroFrontend and ClusterMicroFrontend CRs","anchor":"security-guidelines-for-microfrontend-and-clustermicrofrontend-crs"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"MicroFrontend","anchor":"microfrontend"},{"name":"ClusterMicroFrontend","anchor":"clustermicrofrontend"},{"name":"BackendModule","anchor":"backendmodule"}]}]},{"id":"asset-store","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Asset custom resource lifecycle","anchor":"asset-custom-resource-lifecycle"},{"name":"Bucket custom resource lifecycle","anchor":"bucket-custom-resource-lifecycle"},{"name":"Minio and Minio Gateway","anchor":"minio-and-minio-gateway"},{"name":"Asset Metadata Service","anchor":"asset-metadata-service"},{"name":"Asset Upload Service","anchor":"asset-upload-service"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Asset","anchor":"asset"},{"name":"Bucket","anchor":"bucket"},{"name":"ClusterAsset","anchor":"clusterasset"},{"name":"ClusterBucket","anchor":"clusterbucket"}]}]},{"id":"headless-cms","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Headless CMS in the Console","anchor":"headless-cms-in-the-console"},{"name":"DocsTopic custom resource lifecycle","anchor":"docstopic-custom-resource-lifecycle"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"DocsTopic","anchor":"docstopic"},{"name":"ClusterDocsTopic","anchor":"clusterdocstopic"}]}]}]},"manifest":{"root":[{"displayName":"Kyma","id":"kyma"}],"components":[{"displayName":"Security","id":"security"},{"displayName":"Service Catalog","id":"service-catalog"},{"displayName":"Helm Broker","id":"helm-broker"},{"displayName":"Application Connector","id":"application-connector"},{"displayName":"Event Bus","id":"event-bus"},{"displayName":"Service Mesh","id":"service-mesh"},{"displayName":"Serverless","id":"serverless"},{"displayName":"Monitoring","id":"monitoring"},{"displayName":"Tracing","id":"tracing"},{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Logging","id":"logging"},{"displayName":"Backup","id":"backup"},{"displayName":"Console","id":"console"},{"displayName":"Asset Store","id":"asset-store"},{"displayName":"Headless CMS","id":"headless-cms"}]},"assetsPath":"/assets/docs/master/kyma/docs/assets/","locale":"en"}}