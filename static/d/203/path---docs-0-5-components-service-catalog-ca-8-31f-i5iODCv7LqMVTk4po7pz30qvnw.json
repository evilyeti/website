{"pageContext":{"version":"0.5","versions":{"releases":["0.9","0.8","0.7","0.6","0.5","0.4"],"prereleases":["1.0"],"branches":["master"]},"content":{"id":"service-catalog","displayName":"Service Catalog","description":"Overal documentation for Service Catalog","type":"components","docs":[{"order":"001-overview-service-catalog","title":"Overview","source":"\nThe Service Catalog is a grouping of reusable, integrated services from all Service Brokers registered in Kyma. Its purpose is to provide an easy way for Kyma users to access services that the Service Brokers manage and use them in their applications.\n\nDue to the fact that Kyma runs on Kubernetes, you can easily instantiate a service instance that a third party provides and maintains, such as a database. You can consume it from Kyma without extensive knowledge about the clustering of such a datastore service and the responsibility for its upgrades and maintenance. You can also easily provision an instance of the software offering that a Service Broker registered in Kyma exposes, and bind it with an application running in the Kyma cluster.\n\nYou can perform the following operations in the Service Catalog:\n\n- Expose the consumable services by listing them with all the details, including the documentation and the consumption plans.\n- Consume the services by provisioning them in a given Environment, which is Kyma's representation of the Kubernetes Namespace.\n- Bind the services to the applications through Secrets.\n"},{"order":"010-details-resources","title":"Resources","source":"\nThis document includes an overview of resources that the Kyma Service Catalog provides.\n\n>**NOTE:** The \"Cluster\" prefix in front of resources means they are cluster-wide. Resources without that prefix refer to the Environment scope.   \n\n* **ClusterServiceBroker** is an endpoint for a set of managed services that a third party offers and maintains.\n\n* **ClusterServiceClass** is a managed service exposed by a given ClusterServiceBroker. When a cluster administrator registers a new Service Broker in the Service Catalog, the Service Catalog controller obtains new services exposed by the Service Broker and renders them in the cluster as ClusterServiceClasses. A ClusterServiceClass is synonymous with a service in the Service Catalog.\n\n* **ClusterServicePlan** is a variation of a ClusterServiceClass that offers different levels of quality, configuration options, and the cost of a given service. Contrary to the ClusterServiceClass, which is purely descriptive, the ClusterServicePlan provides technical information to the ClusterServiceBroker on this part of the service that the ClusterServiceBroker can expose.\n\n* **ServiceBroker** is any Service Broker registered in a given Environment where it exposes ServiceClasses and ServicePlans that are available only in that Environment.\n\n* **ServiceClass**  is an Environment-wide representation of a ClusterServiceClass. Similarly to the ClusterServiceClass, it is synonymous with a service in the Service Catalog.\n\n* **ServicePlan** is an Environment-wide representation of a ClusterServicePlan.\n\n* **ServiceInstance** is a provisioned instance of a ClusterServiceClass to use in one or more cluster applications.\n\n* **ServiceBinding** is a link between a ServiceInstance and an application that cluster users create to request credentials or configuration details for a given ServiceInstance.\n\n* **Secret** is a basic resource to transfer credentials or configuration details that the application uses to consume a ServiceInstance. The service binding process leads to the creation of a Secret.\n\n* **ServiceBindingUsage** is a Kyma custom resource that allows the ServiceBindingUsage controller to inject Secrets into a given application.\n\n* **UsageKind** is a Kyma custom resource that defines which resources can be bound with the ServiceBinding and how to bind them..\n","type":"Details"},{"order":"011-details-add-service-to-the-catalog","title":"Add a service to the Catalog","source":"\nIn general, the Service Catalog can expose a service from any Service Broker that is registered in Kyma in accordance with the [Open Service Broker API](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md) specification.\n\nThe Kyma Service Catalog is currently integrated with the following Service Brokers:\n* Azure Broker\n* Remote Environment Broker\n* Helm Broker (experimental)\n\nFor details on how to build and register your own Service Broker to expose more services and plans to the cluster users, see the Service Brokers **Overview** document.\n\n>**NOTE:** The Service Catalog has the Istio sidecar injected. To enable the communication between the Service Catalog and Service Brokers, either inject Istio sidecar into all brokers or disable mutual TLS authentication.\n","type":"Details"},{"order":"012-details-provisioning-and-binding","title":"Provisioning and binding","source":"\nProvisioning a service means creating an instance of a service. When you consume a specific ClusterServiceClass or a ServiceClass, and the system provisions a ServiceInstance, you need credentials for this service. To obtain credentials, create a ServiceBinding resource using the API of the Service Catalog. One instance can have numerous bindings to use in the application. When you raise a binding request, the system returns the credentials in the form of a Secret. The system creates a Secret in a given Environment.\n\n> **NOTE:** The security in Kyma relies on the Kubernetes concept of a [Namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/). Kyma Environment is a security boundary. If the Secret exists in the Environment, the administrator can inject it to any Deployment. The Service Broker cannot prevent other applications from consuming a created Secret. Therefore, to ensure a stronger level of isolation and security, use a dedicated Environment and request separate bindings for each Deployment.\n\nThe Secret allows you to run the service successfully. However, a problem appears each time you need to change the definition of the `yaml` file in the Deployment to specify the Secrets' usage. The manual process of editing the file is tedious and time-consuming. Kyma handles it by offering a custom resource called ServiceBindingUsage. This custom resource applies the Kubernetes [PodPreset](https://kubernetes.io/docs/concepts/workloads/pods/podpreset/) resource and allows you to enforce an automated flow in which the ServiceBindingUsage controller injects ServiceBindings into a given Application or Function.\n\n## Details\n\nThis section provides a simplified, graphic representation of the basic operations in the Service Catalog.\n\n### Provisioning and binding flow\n\nThe diagram shows an overview of interactions between all resources related to Kyma provisioning and binding, and the reverting, deprovisioning, and unbinding operations.\n\n![Kyma provisioning and binding](assets/provisioning-and-binding.png)\n\nThe process of provisioning and binding invokes the creation of three custom resources:\n- ServiceInstance\n- ServiceBinding\n- ServiceBindingUsage\n\nThe system allows you to create these custom resources in any order, but within a timeout period.\n\nWhen you invoke the deprovisioning and unbinding actions, the system deletes all three custom resources. Similar to the creation process dependencies, the system allows you to delete ServiceInstance and ServiceBinding in any order, but within a timeout period. However, before you delete the ServiceBinding, make sure you remove the ServiceBindingUsage first. For more details, see the [section](#details-provisioning-and-binding-delete-a-servicebinding) on deleting a ServiceBinding.\n\n### Provision a service\n\nTo provision a service, create a ServiceInstance custom resource. Generally speaking, provisioning is a process in which the Service Broker creates a new instance of a service. The form and scope of this instance depends on the Service Broker.\n\n![Kyma provisioning](assets/provisioning.png)\n\n### Deprovision a service\n\nTo deprovision a given service, delete the ServiceInstance custom resource. As part of this operation, the Service Broker deletes any resources created during the provisioning. When the process completes, the service becomes unavailable.\n\n![Kyma deprovisioning](assets/deprovisioning.png)\n\n> **NOTE:** You can deprovision a service only if no corresponding ServiceBinding for a given ServiceInstance exists.\n\n### Create a ServiceBinding\n\nKyma binding operation consists of two phases:\n- The system gathers the information necessary to connect to the ServiceInstance and authenticate it. The Service Catalog handles this phase directly, without the use of any additional Kyma custom resources.\n- The system must make the information it collected available to the application. Since the Service Catalog does not provide this functionality, you must create a ServiceBindingUsage custom resource.\n\n![Kyma binding](assets/binding.png)\n\n> **NOTE:** The system allows you to create the ServiceBinding and ServiceBindingUsage resources at the same time.\n\n### Bind with other resources\n\nThe UsageKind is a cluster-wide custom resource which allows you to bind a ServiceInstance to any resource. By default, Kyma provides two UsageKinds which enable binding either to a Deployment or Function. You can add more UsageKinds if you want to bind your ServiceInstance to other types of resources. The UsageKind contains information on the way in which binding to this custom resource is conducted. The ServiceBindingUsage uses this information to inject Secrets to the Application.\n\n![Kyma UsageKind](assets/usagekind.png)\n\n### Delete a ServiceBinding\n\nKyma unbinding can be achieved in two ways:\n1. Delete the ServiceBindingUsage. The Secret injected into application will be deleted by BindingUsageController but the Secret still exist.\n2. Delete the ServiceBinding. It deletes the Secret and triggers the deletion of all the related ServiceBindingUsages. \n\n![Kyma unbinding](assets/unbinding.png)\n","type":"Details"},{"order":"014-details-etcd-database","title":"Etcd Database","source":"\nThe Service Catalog requires an `etcd` database cluster for a production use.\nIt has a separate `etcd` cluster defined in the Service Catalog [etcd-stateful][sc-etcd-sub-chart] sub-chart.\nThe [etcd-backup-operator][etcd-backup-operator] executes the backup procedure.\n\n## Details\n\nThis section describes the backup and restore processes of the `etcd` cluster for the Service Catalog.\n\n### Backup\n\nTo execute the backup process, you must set the following values in the [core][core-chart-values] chart:\n\n| Property name              | Description |\n|---------------------------------------------------|---|\n| **global.etcdBackup.enabled**                       | If set to `true`, the [etcd-operator][etcd-operator-chart] chart and the Service Catalog [sub-chart][sc-backup-sub-chart] installs the CronJob which executes periodically the [Etcd Backup][etcd-backup-app] application. The etcd-operator also creates the [Secret][abs-creds] with the **storage-account** and **storage-key** keys. For more information on how to configure the backup CronJob, see the [Etcd Backup][etcd-backup-app-readme] documentation. |\n| **global.etcdBackup.containerName**                 | The ABS container to store the backup. |\n| **etcd-operator.backupOperator.abs.storageAccount** | The name of the storage account for the Azure Blob Storage (ABS). It stores the value for the **storage-account** Secret key. |\n| **etcd-operator.backupOperator.abs.storageKey**     | The key value of the storage account for the ABS. It stores the value for the **storage-key** Secret key. |\n\n> **NOTE:** If you set the **storageAccount**, **storageKey**, and **containerName** properties, the **global.etcdBackup.enabled** must be set to `true`.\n\n### Restore\n\nFollow this instruction to restore an `etcd` cluster from the existing backup.\n\n1. Export the **ABS_PATH** environment variable with the path to the last successful backup file.\n```bash\nexport ABS_PATH=$(kubectl get cm -n kyma-system sc-recorded-etcd-backup-data -o=jsonpath='{.data.abs-backup-file-path-from-last-success}')\nexport BACKUP_FILE_NAME=etcd.backup\n```\n\n2. Download the backup to the local workstation. You can do it from the portal or by using [azure cli][az-cli]. Set the downloaded file path:\n\n```bash\nexport BACKUP_FILE_NAME=/path/to/downloaded/file\n```\n\n3. Copy the backup file to every running Pod of the StatefulSet.\n\n```bash\nfor i in {0..2};\ndo\nkubectl cp ./$BACKUP_FILE_NAME kyma-system/core-catalog-etcd-stateful-$i:/$BACKUP_FILE_NAME\ndone\n```\n\n4. Restore the backup on every Pod of the StatefulSet.\n\n```bash\nfor i in {0..2};\ndo\n  remoteCommand=\"etcdctl snapshot restore /$BACKUP_FILE_NAME \"\n  remoteCommand+=\"--name core-catalog-etcd-stateful-$i --initial-cluster \"\n  remoteCommand+=\"core-catalog-etcd-stateful-0=https://core-catalog-etcd-stateful-0.core-catalog-etcd-stateful.kyma-system.svc.cluster.local:2380,\"\n  remoteCommand+=\"core-catalog-etcd-stateful-1=https://core-catalog-etcd-stateful-1.core-catalog-etcd-stateful.kyma-system.svc.cluster.local:2380,\"\n  remoteCommand+=\"core-catalog-etcd-stateful-2=https://core-catalog-etcd-stateful-2.core-catalog-etcd-stateful.kyma-system.svc.cluster.local:2380 \"\n  remoteCommand+=\"--initial-cluster-token etcd-cluster-1 \"\n  remoteCommand+=\"--initial-advertise-peer-urls https://core-catalog-etcd-stateful-$i.core-catalog-etcd-stateful.kyma-system.svc.cluster.local:2380\"\n\n  kubectl exec core-catalog-etcd-stateful-$i -n kyma-system -- sh -c \"rm -rf core-catalog-etcd-stateful-$i.etcd\"\n  kubectl exec core-catalog-etcd-stateful-$i -n kyma-system -- sh -c \"rm -rf /var/run/etcd/backup.etcd\"\n  kubectl exec core-catalog-etcd-stateful-$i -n kyma-system -- sh -c \"$remoteCommand\"\n  kubectl exec core-catalog-etcd-stateful-$i -n kyma-system -- sh -c \"mv -f core-catalog-etcd-stateful-$i.etcd /var/run/etcd/backup.etcd\"\n  kubectl exec core-catalog-etcd-stateful-$i -n kyma-system -- sh -c \"rm $BACKUP_FILE_NAME\"\ndone\n```\n\n5. Delete old Pods.\n\n```bash\nkubectl delete pod core-catalog-etcd-stateful-0 core-catalog-etcd-stateful-1 core-catalog-etcd-stateful-2 -n kyma-system\n```\n\n[etcd-backup-operator]:https://github.com/coreos/etcd-operator/blob/master/doc/user/walkthrough/backup-operator.md\n\n<!-- These absolute paths should be replaced with the relative links after adding this functionality to Kyma -->\n[az-cli]:https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest\n\n[sc-etcd-sub-chart]:https://github.com/kyma-project/kyma/blob/master/resources/core/charts/service-catalog/charts/etcd-stateful/templates\n[sc-backup-sub-chart]:https://github.com/kyma-project/kyma/blob/master/resources/core/charts/service-catalog/charts/etcd-stateful/templates/05-backup-job.yaml\n[etcd-operator-chart]:https://github.com/kyma-project/kyma/blob/master/resources/core/charts/etcd-operator\n[etcd-backup-operator-chart]:https://github.com/kyma-project/kyma/blob/master/resources/core/charts/etcd-operator/templates/backup-deployment.yaml\n[core-chart-values]:https://github.com/kyma-project/kyma/blob/master/resources/core/values.yaml\n\n[etcd-backup-app-readme]:https://github.com/kyma-project/kyma/blob/master/tools/etcd-backup/README.md\n[etcd-backup-app]:https://github.com/kyma-project/kyma/blob/master/tools/etcd-backup\n\n[abs-creds]:https://github.com/kyma-project/kyma/blob/master/resources/core/charts/etcd-operator/templates/etcd-backup-abs-storage-secret.yaml\n","type":"Details"},{"order":"020-architecture-service-catalog","title":"Architecture","source":"\nThe diagram and steps describe the Service Catalog workflow and the roles of specific cluster and Environment-wide resources in this process:\n\n![Service Catalog flow](assets/service-catalog-flow.svg)\n\n1. The Kyma installation results in the registration of the default Service Brokers in the Kyma cluster. The Kyma administrator can manually register other ClusterServiceBrokers in the Kyma cluster. The Kyma user can also register a Service Broker in a given Environment.\n\n2. Inside the cluster, each ClusterServiceBroker exposes services that are ClusterServiceClasses in their different variations called ClusterServicePlans. Similarly, the ServiceBroker registered in a given Environment exposes ServiceClasses and ServicePlans only in this specific Environment.\n\n3. In the Console UI or CLI, the Kyma user lists all exposed cluster-wide and Environment-specific services and requests to create instances of those services in the Environment.\n\n4. The Kyma user creates bindings to the ServiceInstances to allow the given applications to access the provisioned services.\n"},{"order":"030-cli-reference","title":"CLI reference","source":"\nManagement of the Service Catalog is based on Kubernetes resources and the custom resources specifically defined for Kyma. Manage all of these resources through [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/).\n\n## Details\n\nThis section describes the resource names to use in the kubectl command line, the command syntax, and examples of use.\n\n### Resource types\n\nService Catalog operations use the following resources:\n\n| Singular name      | Plural name         |\n| ------------------ |---------------------|\n|clusterservicebroker|clusterservicebrokers|\n|clusterserviceclass |clusterserviceclasses|\n|clusterserviceplan  |clusterserviceplans  |\n|secret              |secrets              |\n|servicebinding      |servicebindings      |\n|servicebindingusage |servicebindingusages |\n|servicebroker       |servicebrokers       |\n|serviceclass        |serviceclasses       |\n|serviceinstance     |serviceinstances     |\n|serviceplan         |serviceplans         |\n\n\n### Syntax\n\nFollow the `kubectl` syntax, `kubectl {command} {type} {name} {flags}`, where:\n\n* {command} is any command, such as `describe`.\n* {type} is a resource type, such as `clusterserviceclass`.\n* {name} is the name of a given resource type. Use {name} to make the command return the details of a given resource.\n* {flags} specifies the scope of the information. For example, use flags to define the Namespace from which to get the information.\n\n### Examples\nThe following examples show how to create a ServiceInstance, how to get a list of ClusterServiceClasses and a list of ClusterServiceClasses with human-readable names, a list of ClusterServicePlans, and a list of all ServiceInstances.\n\n* Create a ServiceInstance using the example of the Redis ServiceInstance for the 0.1.3 version of the Service Catalog:\n\n```\ncat <<EOF | kubectl create -f -\napiVersion: servicecatalog.k8s.io/v1beta1\nkind: ServiceInstance\nmetadata:\n  name: my-instance\n  namespace: stage\n\nspec:\n  clusterServiceClassExternalName: redis\n  clusterServicePlanExternalName: micro\n  parameters:\n     \"imagePullPolicy\": \"Always\"\nEOF\n```\n\n* Get the list of all ClusterServiceClasses:\n```\nkubectl get clusterserviceclasses\n```\n* Get the list of all ClusterServiceClasses and their human-readable names:\n```\nkubectl get clusterserviceclasses -o=custom-columns=NAME:.metadata.name,EXTERNAL\\ NAME:.spec.externalName\n```\n\n* Get the list of all ClusterServicePlans and associated ClusterServiceClasses:\n```\nkubectl get clusterserviceplans -o=custom-columns=NAME:.metadata.name,EXTERNAL\\ NAME:.spec.externalName,EXTERNAL\\ SERVICE\\ CLASS:.spec.clusterServiceClassRef\n```\n* Get the list of all ServiceInstances from all Namespaces:\n```\nkubectl get serviceinstances --all-namespaces\n```\n"},{"order":"040-cr-service-binding-usage","title":"ServiceBindingUsage","source":"\nThe `servicebindingusages.servicecatalog.kyma.cx` Custom Resource Definition (CRD) is a detailed description of the kind of data and the format used to inject Secrets to the application. To get the up-to-date CRD and show the output in the `yaml` format, run this command:\n\n```\nkubectl get crd servicebindingusages.servicecatalog.kyma.cx -o yaml\n```\n\n## Sample custom resource\n\nThis is a sample resource in which the ServiceBindingUsage injects a Secret associated with the `redis-instance-binding` ServiceBinding to the `redis-client` Deployment in the `production` Namespace. This example has the **conditions.status** field set to `true`, which means that the ServiceBinding injection is successful. If this field is set to `false`, the **message** and **reason** fields appear.\n\n```\napiVersion: servicecatalog.kyma.cx/v1alpha1\nkind: ServiceBindingUsage\nmetadata:\n name: redis-client-binding-usage\n namespace: production\n \"ownerReferences\": [\n    {\n       \"apiVersion\": \"servicecatalog.k8s.io/v1beta1\",\n       \"kind\": \"ServiceBinding\",\n       \"name\": \"redis-instance-binding\",\n       \"uid\": \"65cc140a-db6a-11e8-abe7-0242ac110023\"\n    }\n ],\nspec:\n serviceBindingRef:\n   name: redis-instance-binding\n usedBy:\n   kind: deployment\n   name: redis-client\n parameters:\n   envPrefix:\n     name: \"pico-bello\"\nstatus:\n    conditions:\n    - lastTransitionTime: 2018-06-26T10:52:05Z\n      lastUpdateTime: 2018-06-26T10:52:05Z\n      status: \"True\"\n      type: Ready\n```\n\n## Custom resource parameters\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n\n| Parameter   |      Mandatory      |  Description |\n|:----------:|:-------------:|:------|\n| **metadata.name** |    **YES**   | Specifies the name of the CR. |\n| **metadata.namespace** |    **YES**   | Specifies the Namespace in which the CR is created. |\n| **metadata.ownerReferences** |    **YES**   | Contains an ownerReference to the binding specified at **spec.serviceBindingRef.name** field if the binding exist. |\n| **spec.serviceBindingRef.name** |    **YES**   | Specifies the name of the ServiceBinding. |\n| **spec.usedBy** |    **YES**   | Specifies the application into which the Secret is injected. |\n| **spec.usedBy.kind** |    **YES**   | Specifies the name of the UsageKind custom resource. |\n| **spec.usedBy.name** |    **YES**   | Specifies the name of the application. |\n| **spec.parameters.envPrefix** |    **NO**   | Defines the prefix of environment variables environment variables that the ServiceBindingUsage injects. The prefixing is disabled by default. |\n| **spec.parameters.envPrefix.name** |    **YES**   | Specifies the name of the prefix. This field is mandatory if **envPrefix** is specified.  |\n| **status.conditions** |    **NO**   | Specifies the state of the ServiceBindingUsage.|\n| **status.conditions.lastTransitionTime** |    **NO**   | Specifies the time when the Binding Usage Controller processes the ServiceBindingUsage for the first time or when the **status.conditions.status** field changes. |\n| **status.conditions.lastUpdateTime** |    **NO**   | Specifies the time of the last ServiceBindingUsage condition update. |\n| **status.conditions.status** |    **NO**   |  Specifies whether the status of the **status.conditions.type** field is `True` or `False`. |\n| **status.conditions.type** |    **NO**   | Defines the type of the condition. The value of this field is always `Ready`. |\n| **message** |    **NO**   | Describes in a human-readable way why the ServiceBinding injection has failed. |\n| **reason** |    **NO**   | Specifies a unique, one-word, CamelCase reason for the condition's last transition. |\n\n\n## Related resources and components\n\nThese are the resources related to this CR:\n\n| Custom resource   |   Description |\n|:----------:|:------|\n| UsageKind |  Provides information where to inject Secrets. |\n| [ServiceBinding](https://kubernetes.io/docs/concepts/extend-kubernetes/service-catalog/#api-resources) |  Provides Secrets to inject.  |\n\n\nThese components use this CR:\n\n| Component   |   Description |\n|:----------:|:------|\n| Binding Usage Controller |  Reacts to every action of creating, updating, or deleting ServiceBindingUsages in all Namespaces, and uses ServiceBindingUsage data to inject binding. |\n| UI API Layer |  Exposes the given CR to the Console UI. It also allows you to create and delete a ServiceBindingUsage. |\n","type":"Custom Resource"},{"order":"041-cr-usage-kind","title":"UsageKind","source":"\nThe `usagekinds.servicecatalog.kyma.cx` Custom Resource Definition (CRD) is a detailed description of the kind of data and the format used to define which resources can be bound with the ServiceBinding and how to bind them. To get the up-to-date CRD and show the output in the `yaml` format, run this command:\n\n```\nkubectl get crd usagekinds.servicecatalog.kyma.cx -o yaml\n```\n\n## Sample custom resource\n\nThis is a sample resource that allows you to bind a given resource with the ServiceBinding. This example has a **resource** section specified as `function`. You can adjust this section to point to any other kind of resource.\n\n```\napiVersion: servicecatalog.kyma.cx/v1alpha1\nkind: UsageKind\nmetadata:\n   name: function\nspec:\n   displayName: Function\n   resource:\n     group: kubeless.io\n     kind: function\n     version: v1beta1\n   labelsPath: spec.deployment.spec.template.metadata.labels\n```\n\n## Custom resource parameters\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n\n| Parameter   |      Mandatory      |  Description |\n|:----------:|:-------------:|:------|\n| **metadata.name** |    **YES**   | Specifies the name of the CR. |\n| **spec.displayName** |    **YES**   | Specifies a human-readable name of the UsageKind. |\n| **spec.resource** |    **YES**   | Specifies a resource which is bound with the ServiceBinding. The target resource is specified by its resource group, kind, and version. |\n| **spec.resource.group** |    **YES**   | Specifies the group of the resource. |\n| **spec.resource.kind** |    **YES**   | Specifies the kind of the resource. |\n| **spec.resource.version** |    **YES**   | Specifies the version of the resource. |\n| **spec.labelsPath** |    **YES**   | Specifies a path to the key that contains labels which are later injected into Pods. |\n\n\n## Related resources and components\n\nThese are the resources related to this CR:\n\n| Custom resource   |   Description |\n|:----------:|:------|\n| ServiceBindingUsage |  Contains the reference to the UsageKind. |\n\nThese components use this CR:\n\n| Component   |   Description |\n|:----------:|:------|\n| Binding Usage Controller |  Uses the UsageKind **spec.resource** and **spec.labelsPath** parameters to find a resource and a path to which it should inject Secrets. |\n| UI API Layer |  Exposes the given CR to the Console UI. |\n","type":"Custom Resource"},{"order":"050-gs-broker-registration","title":"Register a ClusterServiceBroker","source":"\nThis Getting Started guide shows how to register a new ClusterServiceBroker in the Service Catalog. Follow this guide to register a cluster-wide [UPS Broker](https://github.com/kubernetes-incubator/service-catalog/tree/master/charts/ups-broker) in the Service Catalog.\n\n## Prerequisites\n\n* [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl)\n* [helm](https://github.com/helm/helm#install)\n\n## Steps\n\n1. Clone the [`service-catalog`](https://github.com/kubernetes-incubator/service-catalog) repository:\n    ```\n    git clone https://github.com/kubernetes-incubator/service-catalog.git\n    ```\n\n2.  Run this command to install the chart with the `ups-broker` name in the `stage` Namespace:\n      ```\n     helm install service-catalog/charts/ups-broker --name ups-broker --namespace stage\n     ```\n\n3. Register your broker:\n     ```\n    kubectl create -f service-catalog/contrib/examples/walkthrough/ups-broker.yaml\n    ```\n     After you successfully register your ClusterServiceBroker, the Service Catalog periodically fetches services from this broker and creates ClusterServiceClasses from them.\n\n4. Check the status of the broker:\n     ```\n    kubectl get clusterservicebrokers ups-broker -o jsonpath=\"{.status.conditions}\"\n    ```\n\n    The output looks as follows:\n      ```\n    {\n    \"lastTransitionTime\": \"2018-10-26T12:03:32Z\",\n    \"message\": \"Successfully fetched catalog entries from broker.\",\n    \"reason\": \"FetchedCatalog\",\n    \"status\": \"True\",\n    \"type\": \"Ready\"\n    }\n     ```\n\n5. View ClusterServiceClasses that this broker provides:\n     ```\n    kubectl get clusterserviceclasses\n      ```\n\n     These are the UPS Broker ClusterServiceClasses:\n     ```\n    NAME                                   EXTERNAL NAME\n     4f6e6cf6-ffdd-425f-a2c7-3c9258ad2468   user-provided-service\n     5f6e6cf6-ffdd-425f-a2c7-3c9258ad2468   user-provided-service-single-plan\n     8a6229d4-239e-4790-ba1f-8367004d0473   user-provided-service-with-schemas\n     ```\n","type":"Getting Started"}]},"navigation":{"topics":[{"id":"kyma","contentType":"root","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"In a nutshell","anchor":"in-a-nutshell"},{"name":"Main features","anchor":"main-features"},{"name":"Technology stack","anchor":"technology-stack"},{"name":"Key components","anchor":"key-components"},{"name":"Kyma and Knative - brothers in arms","anchor":"kyma-and-knative---brothers-in-arms"},{"name":"How to start","anchor":"how-to-start"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Components","anchor":"components"},{"name":"Environments","anchor":"environments"},{"name":"Testing Kyma","anchor":"testing-kyma"},{"name":"Charts","anchor":"charts"},{"name":"Deploy with a private Docker registry","anchor":"deploy-with-a-private-docker-registry"}]},{"topicType":"Installation","name":"Installation","anchor":"installation","titles":[{"name":"Install Kyma locally from the release","anchor":"install-kyma-locally-from-the-release"},{"name":"Install Kyma locally from sources","anchor":"install-kyma-locally-from-sources"},{"name":"Install Kyma on a GKE cluster","anchor":"install-kyma-on-a-gke-cluster"},{"name":"Local installation scripts","anchor":"local-installation-scripts"},{"name":"Install subcomponents","anchor":"install-subcomponents"},{"name":"Reinstall Kyma","anchor":"reinstall-kyma"},{"name":"Installation with custom Istio deployment","anchor":"installation-with-custom-istio-deployment"}]},{"topicType":"Getting Started","name":"Getting Started","anchor":"getting-started","titles":[{"name":"Sample service deployment on local","anchor":"sample-service-deployment-on-local"},{"name":"Sample service deployment on a cluster","anchor":"sample-service-deployment-on-a-cluster"},{"name":"Develop a service locally without using Docker","anchor":"develop-a-service-locally-without-using-docker"},{"name":"Publish a service Docker image and deploy it to Kyma","anchor":"publish-a-service-docker-image-and-deploy-it-to-kyma"},{"name":"Helm overrides for Kyma installation","anchor":"helm-overrides-for-kyma-installation"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Installation","anchor":"installation"}]}]},{"id":"security","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Kubeconfig generator","anchor":"kubeconfig-generator"},{"name":"Add an Identity Provider to Dex","anchor":"add-an-identity-provider-to-dex"},{"name":"Manage static users in Dex","anchor":"manage-static-users-in-dex"},{"name":"Update TLS certificate","anchor":"update-tls-certificate"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Group","anchor":"group"},{"name":"Identity Provider Presets","anchor":"identity-provider-presets"}]}]},{"id":"service-catalog","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Resources","anchor":"resources"},{"name":"Add a service to the Catalog","anchor":"add-a-service-to-the-catalog"},{"name":"Provisioning and binding","anchor":"provisioning-and-binding"},{"name":"Etcd Database","anchor":"etcd-database"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"ServiceBindingUsage","anchor":"servicebindingusage"},{"name":"UsageKind","anchor":"usagekind"}]},{"topicType":"Getting Started","name":"Getting Started","anchor":"getting-started","titles":[{"name":"Register a ClusterServiceBroker","anchor":"register-a-clusterservicebroker"}]}]},{"id":"service-brokers","contentType":"components","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"Overview","anchor":"overview"},{"name":"Azure Broker","anchor":"azure-broker"},{"name":"Remote Environment Broker","anchor":"remote-environment-broker"},{"name":"Helm Broker","anchor":"helm-broker"}]},{"topicType":"Configuration","name":"Configuration","anchor":"configuration","titles":[{"name":"Configure Helm Broker","anchor":"configure-helm-broker"},{"name":"How to create a bundle","anchor":"how-to-create-a-bundle"},{"name":"Binding bundles","anchor":"binding-bundles"},{"name":"Enable the Azure Broker for local deployment","anchor":"enable-the-azure-broker-for-local-deployment"}]},{"topicType":"Architecture","name":"Architecture","anchor":"architecture","titles":[{"name":"The Remote Environment Broker architecture","anchor":"the-remote-environment-broker-architecture"},{"name":"Helm Broker architecture","anchor":"helm-broker-architecture"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"EventActivation","anchor":"eventactivation"}]}]},{"id":"application-connector","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Architecture","name":"Architecture","anchor":"architecture","titles":[{"name":"Application Connector components","anchor":"application-connector-components"},{"name":"Connector Service","anchor":"connector-service"},{"name":"Proxy Service","anchor":"proxy-service"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Security","anchor":"security"},{"name":"Access the Application Connector on a local Kyma deployment","anchor":"access-the-application-connector-on-a-local-kyma-deployment"},{"name":"Consume applications through the Service Catalog","anchor":"consume-applications-through-the-service-catalog"},{"name":"Metadata Service","anchor":"metadata-service"},{"name":"Pass an access token in a request header","anchor":"pass-an-access-token-in-a-request-header"}]},{"topicType":"API","name":"API","anchor":"api","titles":[{"name":"Connector Service","anchor":"connector-service"},{"name":"Metadata Service","anchor":"metadata-service"},{"name":"Event Service","anchor":"event-service"}]},{"topicType":"Getting Started","name":"Getting Started","anchor":"getting-started","titles":[{"name":"Create a new Remote Environment","anchor":"create-a-new-remote-environment"},{"name":"Get the client certificate","anchor":"get-the-client-certificate"},{"name":"Register a service","anchor":"register-a-service"},{"name":"Bind a Remote Environment to an Environment","anchor":"bind-a-remote-environment-to-an-environment"},{"name":"Trigger a lambda with events","anchor":"trigger-a-lambda-with-events"},{"name":"Call a registered external service from Kyma","anchor":"call-a-registered-external-service-from-kyma"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"RemoteEnvironment","anchor":"remoteenvironment"},{"name":"EnvironmentMapping","anchor":"environmentmapping"}]}]},{"id":"event-bus","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Basic concepts","anchor":"basic-concepts"},{"name":"Event flow requirements","anchor":"event-flow-requirements"},{"name":"Service Programming Model","anchor":"service-programming-model"},{"name":"Troubleshooting","anchor":"troubleshooting"},{"name":"Subscription updates","anchor":"subscription-updates"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Subscription","anchor":"subscription"}]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]}]},{"id":"service-mesh","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Sidecar Proxy Injection","anchor":"sidecar-proxy-injection"},{"name":"Istio patch","anchor":"istio-patch"}]}]},{"id":"serverless","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Custom Resources","anchor":"custom-resources"},{"name":"Managing Lambdas","anchor":"managing-lambdas"},{"name":"The Node.js Programming Model","anchor":"the-node.js-programming-model"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]}]},{"id":"monitoring","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Getting Started","name":"Getting Started","anchor":"getting-started","titles":[{"name":"Expose custom metrics in Kyma","anchor":"expose-custom-metrics-in-kyma"}]}]},{"id":"tracing","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Propagate HTTP headers","anchor":"propagate-http-headers"},{"name":"Trace Comparison","anchor":"trace-comparison"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]}]},{"id":"api-gateway","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Security","anchor":"security"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Api","anchor":"api"}]}]},{"id":"logging","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Access OK Log","anchor":"access-ok-log"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]}]},{"id":"console","contentType":"components","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"Overview","anchor":"overview"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"UI extensibility","anchor":"ui-extensibility"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"MicroFrontend","anchor":"microfrontend"},{"name":"ClusterMicroFrontend","anchor":"clustermicrofrontend"}]}]}]},"manifest":{"root":[{"displayName":"Kyma","id":"kyma"}],"components":[{"displayName":"Security","id":"security"},{"displayName":"Service Catalog","id":"service-catalog"},{"displayName":"Service Brokers","id":"service-brokers"},{"displayName":"Application Connector","id":"application-connector"},{"displayName":"Event Bus","id":"event-bus"},{"displayName":"Service Mesh","id":"service-mesh"},{"displayName":"Serverless","id":"serverless"},{"displayName":"Monitoring","id":"monitoring"},{"displayName":"Tracing","id":"tracing"},{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Logging","id":"logging"},{"displayName":"Console","id":"console"}]},"assetsPath":"/assets/docs/0.5/service-catalog/docs/assets/","locale":"en"}}