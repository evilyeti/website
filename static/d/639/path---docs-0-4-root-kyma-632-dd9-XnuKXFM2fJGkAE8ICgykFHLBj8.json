{"pageContext":{"version":"0.4","versions":{"releases":["0.9","0.8","0.7","0.6","0.5","0.4"],"branches":["master"]},"content":{"id":"kyma","displayName":"Kyma","description":"Overall documentation for Kyma","type":"root","docs":[{"order":"001-overview-kyma","title":"Overview","source":"\nKyma is the easiest and fastest way to connect and extend products in a cloud-native way. Kyma is designed as a centerpiece that brings together different external products and increases their agility and customizability.\n\nKyma allows you to extend and customize the functionality of your products in a quick and modern way, using serverless computing and microservice architecture. The extensions and customizations you create are decoupled from the core applications, which means that deployments are quick, scaling is independent from the core applications, and the changes you make can be easily reverted without causing downtime of the production system.\n\nLiving outside of the core product, Kyma allows you to be completely language-agnostic and customize your solution using the technology stack you want to use, not the one the core product dictates. Additionally, Kyma follows the \"batteries included\" principle and comes with all of the \"plumbing code\" ready to use, allowing you to focus entirely on writing the domain code and business logic.\n\nOut of the box, Kyma comes with:\n  - Security (Service Identity, TLS, Role Based Access Control)\n  - Resilience\n  - Telemetry and reporting\n  - Traffic routing\n  - Fault injection\n\nWhen it comes to technology stacks, Kyma is all about the latest, most modern, and most powerful technologies available. The entire solution is containerized and runs on a [Kubernetes](https://kubernetes.io/) cluster hosted in the [Microsoft Azure](https://azure.microsoft.com/) cloud environment. Customers can access the cluster easily using a single sign on solution based on the [Dex](https://github.com/coreos/dex) identity provider integrated with any [OpenID Connect](https://openid.net/connect/)-compliant identity provider or a SAML2-based enterprise authentication server.\n\nThe communication between services is handled by the [Istio](https://istio.io/) service mesh component, which enables security, monitoring, and tracing without the need to change the application code.\nBuild your applications using services provisioned by one of the many Service Brokers compatible with the [Open Service Broker API](https://www.openservicebrokerapi.org/), and monitor the speed and efficiency of your solutions using [Prometheus](https://prometheus.io/), which gives you the most accurate and up-to-date tracing and telemetry data.\n\nUsing [Minikube](https://github.com/kubernetes/minikube), you can run Kyma locally, develop, and test your solutions on a small scale before you push them to a cluster. Follow the **Local Kyma installation** and **Cluster Kyma installation** Getting Started guides to start exploring in a matter of minutes.\n"},{"order":"002-details-components","title":"Components","source":"\nKyma is built on the foundation of the best and most advanced open-source projects which make up the components readily available for customers to use.\nThis section describes the Kyma components.\n\n## Service Catalog\n\nThe Service Catalog lists all of the services available to Kyma users through the registered Service Brokers. Using the Service Catalog, you can provision new services in the\nKyma [Kubernetes](https://kubernetes.io/) cluster and create bindings between the provisioned service and an application.\n\n## Service Brokers\n\nService Brokers are [Open Service Broker API](https://www.openservicebrokerapi.org/)-compatible servers that manage the lifecycle of one or more services. Each Service Broker registered in Kyma presents the services it offers to the Service Catalog. You can provision these services on a cluster level through the Service Catalog. Out of the box, Kyma comes with three Service Brokers.\nYou can register more [Open Service Broker API](https://www.openservicebrokerapi.org/)-compatible Service Brokers in Kyma and provision the services they offer using the Service Catalog.\n\n## Application Connector\n\nThe Application Connector is a proprietary Kyma solution. This endpoint is the Kyma side of the connection between Kyma and the external solutions. The Application Connector allows you to register the APIs and the Event Catalog, which lists all of the available events, of the connected solution. Additionally, the Application Connector proxies the calls from Kyma to external APIs in a secure way.\n\n## Event Bus\n\nKyma Event Bus receives Events from external solutions and triggers the business logic created with lambda functions and services in Kyma. The Event Bus is based on the [NATS Streaming](https://nats.io/) open source messaging system for cloud-native applications.\n\n## Service Mesh\n\nThe Service Mesh is an infrastructure layer that handles service-to-service communication, proxying, service discovery, traceability, and security independent of the code of the services. Kyma uses the [Istio](https://istio.io/) Service Mesh that enforces RBAC (Role Based Access Control) in the cluster. [Dex](https://github.com/coreos/dex) handles the identity management and identity provider integration. It allows you to integrate any [OpenID Connect](https://openid.net/connect/)-compliant identity provider with Kyma.   \n\n## Serverless\n\nThe Kyma Serverless component allows you to reduce the implementation and operation effort of an application to the absolute minimum. Kyma Serverless provides a platform to run lightweight functions in a cost-efficient and scalable way using JavaScript and Node.js. Kyma Serverless is built on the [Kubeless](http://kubeless.io/) framework, which allows you to deploy lambda functions,\nand uses the [NATS](https://nats.io/) messaging system that monitors business events and triggers functions accordingly.  \n\n## Monitoring\n\nKyma comes bundled with tools that give you the most accurate and up-to-date monitoring data.  [Prometheus](https://prometheus.io/) open source monitoring and alerting toolkit provides this data, which is consumed by different add-ons, including [Grafana](https://grafana.com/) for analytics and monitoring, and [Alertmanager](https://prometheus.io/docs/alerting/alertmanager/) for handling alerts.\n\n## Tracing\n\nThe tracing in Kyma uses the [Jaeger](https://github.com/jaegertracing) distributed tracing system. Use it to analyze performance by scrutinizing the path of the requests sent to and from your service. This information helps you optimize the latency and performance of your solution.\n\n## Logging\n\nLogging in Kyma uses [Logspout](https://github.com/gliderlabs/logspout) and [OK Log](https://github.com/oklog/oklog). Use a plaintext or a regular expression to fetch logs from pods using the OK Log UI.\n","type":"Details"},{"order":"005-details-environments","title":"Environments","source":"\nAn Environment is a custom Kyma security and organizational unit based on the concept of Kubernetes [Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/). Kyma Environments allow you to divide the cluster\ninto smaller units to use for different purposes, such as development and testing.\n\nKyma Environment is a user-created Namespace marked with the `env: \"true\"` label. The Kyma UI only displays the Namespaces marked with the `env: \"true\"` label.\n\n\n## Default Kyma Namespaces\n\nKyma comes configured with default Namespaces dedicated for system-related purposes. The user cannot modify or remove any of these Namespaces.\n\n- `kyma-system` - This Namespace contains all of the Kyma Core components.\n- `kyma-integration` - This Namespace contains all of the Application Connector components responsible for the integration of Kyma and external solutions.\n- `kyma-installer` - This Namespace contains all of the Kyma installer components, objects, and Secrets.\n- `istio-system` - This Namespace contains all of the Istio-related components.\n\n## Environments in Kyma\n\nKyma comes with three Environments ready for you to use. These environments are:\n\n- `production`\n- `qa`\n- `stage`\n\n## Create a new Environment\n\nTo create a new Environment, create a Namespace and mark it with the `env: \"true\"` label. Use this command to do that in a single step:\n\n```\n$ cat <<EOF | kubectl create -f -\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: my-environment\n  labels:\n    env: \"true\"\nEOF\n```\n\nInitially, the system deploys two template roles: `kyma-reader-role` and `kyma-admin-role`. The controller finds the template roles by filtering available roles in the namespace `kyma-system` by the label `env: \"true\"`. The controller copies these roles into the Environment.\n","type":"Details"},{"order":"025-details-local-reinstallation","title":"Reinstall Kyma","source":"\nThe custom scripts allow you to remove Kyma from a Minikube cluster and reinstall Kyma without removing the cluster.\n\n> **NOTE:** These scripts do not delete the cluster from your Minikube. This allows you to quickly reinstall Kyma.\n\n1. Use the `clean-up.sh` script to uninstall Kyma from the cluster. Run:\n  ```\n  scripts/clean-up.sh\n  ```\n\n2. Run this script to reinstall Kyma on an existing cluster:\n  ```\n  cmd/run.sh --skip-minikube-start\n  ```\n","type":"Details"},{"order":"026-details-testing","title":"Testing Kyma","source":"\nFor testing, the Kyma components use the Helm test concept. Place your test under the `templates` directory as a Pod definition that specifies a container with a given command to run.\n\n## Add a new test\n\nThe system bases tests on the Helm broker concept with one modification: adding a Pod label. Before you create a test, see the official [Chart Tests](https://github.com/kubernetes/helm/blob/release-2.7/docs/chart_tests.md) documentation. Then, add the `\"helm-chart-test\": \"true\"` label to your Pod template.\n\nSee the following example of a test prepared for Dex:\n\n```\n# Chart tree\ndex\n├── Chart.yaml\n├── README.md\n├── templates\n│   ├── tests\n│   │   └── test-dex-connection.yaml\n│   ├── dex-deployment.yaml\n│   ├── dex-ingress.yaml\n│   ├── dex-rbac-role.yaml\n│   ├── dex-service.yaml\n│   ├── pre-install-dex-account.yaml\n│   ├── pre-install-dex-config-map.yaml\n│   └── pre-install-dex-secrets.yaml\n└── values.yaml\n```\n\nThe test adds a new **test-dex-connection.yaml** under the `templates/tests` directory.\nThis simple test calls the `Dex` endpoint with cURL, defined as follows:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: \"test-{{ template \"fullname\" . }}-connection-dex\"\n  annotations:\n    \"helm.sh/hook\": test-success\n  labels:\n      \"helm-chart-test\": \"true\" # ! Our customization\nspec:\n  hostNetwork: true\n  containers:\n  - name: \"test-{{ template \"fullname\" . }}-connection-dex\"\n    image: tutum/curl:alpine\n    command: [\"/usr/bin/curl\"]\n    args: [\n      \"--fail\",\n      \"http://dex-service.{{ .Release.Namespace }}.svc.cluster.local:5556/.well-known/openid-configuration\"\n    ]\n  restartPolicy: Never\n```\n\n## Test execution\n\nAll tests created for charts under `/resources/core/` run automatically after starting Kyma.\nIf any of the tests fail, the system prints the Pod logs in the terminal, then deletes all the Pods.\n\n>**NOTE:** If you run Kyma locally, by default, the system does not take into account the test's exit code. As a result, the system does not terminate Kyma Docker container, and you can still access it.\nTo force a termination in case of failing tests, use `--exit-on-test-fail` flag when executing `run.sh` script.\n\nCI propagates the exit status of tests. If any test fails, the whole CI job fails as well.\n\nFollow the same guidelines to add a test which is not a part of any `core` component. However, for test execution, see the **Run a test manually** section in this document.\n\n### Run a test manually\n\nTo run a test manually, use the `testing.sh` script located in the `/installation/scripts/` directory which runs all tests defined for `core` releases.\nIf any of the tests fail, the system prints the Pod logs in the terminal, then deletes all the Pods.\n\nAnother option is to run a Helm test directly on your release.\n\n```bash\n$ helm test {your_release_name}\n```\n\nYou can also run your test on custom releases. If you do this, remember to always delete the Pods after a test ends.\n","type":"Details"},{"order":"027-details-charts","title":"Charts","source":"\nKyma uses Helm charts to deliver single components and extensions, as well as the core components. This document contains information about the chart-related technical concepts, dependency management to use with Helm charts, and chart examples.\n\n## Manage dependencies with Init Containers\n\nThe **ADR 003: Init Containers for dependency management** document declares the use of Init Containers as the primary dependency mechanism.\n\n[Init Containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) present a set of distinctive behaviors:\n\n* They always run to completion.\n* They start sequentially, only after the preceding Init Container completes successfully.\n  If any of the Init Containers fails, the Pod restarts. This is always true, unless the `restartPolicy` equals `never`.\n\n[Readiness Probes](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes) ensure that the essential containers are ready to handle requests before you expose them. At a minimum, probes are defined for every container accessible from outside of the Pod. It is recommended to pair the Init Containers with readiness probes to provide a basic dependency management solution.\n\n## Examples\nHere are some examples:\n\n1. Generic\n\n\n```yaml\napiVersion: apps/v1beta2\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.7.9\n        ports:\n        - containerPort: 80\n        readinessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 30\n          timeoutSeconds: 1\n```\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: myapp-pod\nspec:\n  initContainers:\n  - name: init-myservice\n    image: busybox\n    command: ['sh', '-c', 'until nslookup nginx; do echo waiting for nginx; sleep 2; done;']\n  containers:\n  - name: myapp-container\n    image: busybox\n    command: ['sh', '-c', 'echo The app is running! && sleep 3600']\n```\n\n2. Kyma\n\n\n```yaml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: helm-broker\n  labels:\n    app: helm-broker\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: helm-broker\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 0\n  template:\n    metadata:\n      labels:\n        app: helm-broker\n    spec:\n\n      initContainers:\n      - name: init-helm-broker\n        image: eu.gcr.io/kyma-project/alpine-net:0.2.74\n        command: ['sh', '-c', 'until nc -zv core-catalog-controller-manager.kyma-system.svc.cluster.local 8080; do echo waiting for etcd service; sleep 2; done;']\n\n      containers:\n      - name: helm-broker\n        ports:\n        - containerPort: 6699\n        readinessProbe:\n          tcpSocket:\n            port: 6699\n          failureThreshold: 3\n          initialDelaySeconds: 10\n          periodSeconds: 3\n          successThreshold: 1\n          timeoutSeconds: 2\n```\n\n## Support for the Helm wait flag\n\nHigh level Kyma components, such as **core**, come as Helm charts. These charts are installed as part of a single Helm release. To provide ordering for these core components, the Helm client runs with the `--wait` flag. As a result, Tiller waits for the readiness of all of the components, and then evaluates the readiness.\n\nFor `Deployments`, set the strategy to `RollingUpdate` and set the `MaxUnavailable` value to a number lower than the number of replicas. This setting is necessary, as readiness in Helm v2.8.2 is fulfilled if the number of replicas in ready state is not lower than the expected number of replicas:\n\n```\nReadyReplicas >= TotalReplicas - MaxUnavailable\n```\n\n## Chart installation details\n\nThe Tiller server performs the chart installation process. This is the order of operations that happen during the chart installation:\n\n* resolve values\n* recursively gather all templates with the corresponding values\n* sort all templates\n* render all templates\n* separate hooks and manifests from files into sorted lists\n* aggregate all valid manifests from all sub-charts into a single manifest file\n* execute PreInstall hooks\n* create a release using the ReleaseModule API and, if requested, wait for the actual readiness of the resources\n* execute PostInstall hooks\n\n## Notes\n\nAll notes are based on Helm v2.7.2 implementation and are subject to change in feature releases.\n\n* Regardless of how complex a chart is, and regardless of the number of sub-charts it references or consists of, it's always evaluated as one. This means that each Helm release is compiled into a single Kubernetes manifest file when applied on API server.\n\n* Hooks are parsed in the same order as manifest files and returned as a single, global list for the entire chart. For each hook the weight is calculated as a part of this sort.\n\n* Manifests are sorted by `Kind`. You can find the list and the order of the resources on the Kubernetes [Tiller](https://github.com/kubernetes/helm/blob/v2.8.2/pkg/tiller/kind_sorter.go#L29) website.\n\n## Glossary\n\n* **resource** is any document in a chart recognized by Helm or Tiller. This includes manifests, hooks, and notes.\n* **template** is a valid Go template. Many of the resources are also Go templates.\n","type":"Details"},{"order":"028-details-deploy-private-registry","title":"Deploy with a private Docker registry","source":"\nDocker is a free tool to deploy applications and servers. To run an application on Kyma, provide the application binary file as a Docker image located in a Docker registry. Use the `DockerHub` public registry to upload your Docker images for free access to the public. Use a private Docker registry to ensure privacy, increased security, and better availability.\n\nThis document shows how to deploy a Docker image from your private Docker registry to the Kyma cluster.\n\n## Details\n\nThe deployment to Kyma from a private registry differs from the deployment from a public registry. You must provide Secrets accessible in Kyma, and referenced in the `.yaml` deployment file. This section describes how to deploy an image from a private Docker registry to Kyma. Follow the deployment steps:\n\n1. Create a Secret resource.\n2. Write your deployment file.\n3. Submit the file to the Kyma cluster.\n\n### Create a Secret for your private registry\n\nA Secret resource passes your Docker registry credentials to the Kyma cluster in an encrypted form. For more information on Secrets, refer to the [Kubernetes documentation](https://kubernetes.io/docs/concepts/configuration/secret/).\n\nTo create a Secret resource for your Docker registry, run the following command:\n\n```bash\nkubectl create secret docker-registry {secret-name} --docker-server={registry FQN} --docker-username={user-name} --docker-password={password} --docker-email={registry-email} --namespace={namespace}  \n```\n\nRefer to the following example:\n```bash\nkubectl create secret docker-registry docker-registry-secret --docker-server=myregistry:5000 --docker-username=root --docker-password=password --docker-email=example@github.com --namespace=production\n```\n\nThe Secret is associated with a specific Namespace. In the example, the Namespace is `production`. However, you can modify the Secret to point to any desired Namespace.\n\n### Write your deployment file\n\n1. Create the deployment file with the `.yml` extension and name it `deployment.yml`.\n\n2. Describe your deployment in the `.yml` file. Refer to the following example:\n\n```yaml\napiVersion: apps/v1beta2\nkind: Deployment\nmetadata:\n  namespace: production # {production/stage/qa}\n  name: my-deployment # Specify the deployment name.\n  annotations:\n    sidecar.istio.io/inject: true\nspec:\n  replicas: 3 # Specify your replica - how many instances you want from that deployment.\n  selector:\n    matchLabels:\n      app: app-name # Specify the app label. It is optional but it is a good practice.\n  template:\n    metadata:\n      labels:\n        app: app-name # Specify app label. It is optional but it is a good practice.\n        version: v1 # Specify your version.\n    spec:\n      containers:\n      - name: container-name # Specify a meaningful container name.\n        image: myregistry:5000/user-name/image-name:latest # Specify your image {registry FQN/your-username/your-space/image-name:image-version}.\n        ports:\n          - containerPort: 80 # Specify the port to your image.\n      imagePullSecrets:\n        - name: docker-registry-secret # Specify the same Secret name you generated in the previous step for this Namespace.\n        - name: example-secret-name # Specify your Namespace Secret, named `example-secret-name`.\n\n```\n3. Submit you deployment file using this command:\n\n```bash\nkubectl apply -f deployment.yml\n```\nYour deployment is now running on the Kyma cluster.\n","type":"Details"},{"order":"029-details-install-subcomponents","title":"Install subcomponents","source":"\nIt is up to you to decide which subcomponents you install as part of the `core` release. By default, most of the core subcomponents are enabled. If you want to install only specific subcomponents, follow the steps that you need to perform before the local and cluster installation.\n\n## Install subcomponents locally\n\nTo specify whether to install a given core subcomponent on Minikube, use the `manage-component.sh` script before you trigger the Kyma installation. The script consumes two parameters:\n\n- the name of the core subcomponent\n- a Boolean value that determines whether to install the subcomponent (`true`) or not (`false`)\n\nExample:\n\nTo enable the `Azure Broker` subcomponent, run the following command:\n```\nscripts/manage-component.sh azure-broker true\n```\n\nAlternatively, to disable the `Azure Broker` subcomponent, run this command:\n```\nscripts/manage-component.sh azure-broker false\n```\n\n## Install subcomponents on a cluster\n\nInstall subcomponents on a cluster based on Helm conditions described in the `requirements.yaml` file. Read more about the fields in the `requirements.yaml` file [here](https://github.com/helm/helm/blob/master/docs/charts.md#tags-and-condition-fields-in-requirementsyaml).\n\nTo specify whether to install a given core subcomponent, provide override values before you trigger the installation.\n\nExample:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kyma-sub-components\n  namespace: kyma-installer\n  labels:\n    installer: overrides\ndata:\n  azure-broker.enabled: \"true\"\n```\n\n>**NOTE:** Some subcomponents can require additional configuration to work properly.\n\n## Specify subcomponents versions\n\nVersions of the Kyma components are specified in the `values.yaml` file in charts. Two properties, `version` and `dir`, describe each component version. The first one defines the actual docker image tag. The second property describes the directory under which the tagged image is pushed. It is optional and is followed by a forward slash (/).\n\nPossible values of the `dir` property:\n- `pr/` contains images built from the pull request\n- `develop/` contains images built from the `master` branch\n- `rc/` contains images built for a pre-release\n- `` (empty) contains images built for a release\n\nTo override subcomponents versions during Kyma startup, create the `versions-overrides.env` file in the `installation` directory. \n\nThe example overrides the `Environments` component and sets the image version to `0.0.1`, based on the version from the `develop` directory.\n\nExample:\n\n```\nglobal.environments.dir=develop/\nglobal.environments.version=0.0.1\n```","type":"Details"},{"order":"031-gs-local-installation","title":"Local Kyma installation","source":"\nThis Getting Started guide shows developers how to quickly deploy Kyma locally on a Mac, Linux, or Windows. Kyma installs locally using a proprietary installer based on a [Kubernetes operator](https://coreos.com/operators/). The document provides prerequisites, instructions on how to install Kyma locally and verify the deployment, as well as the troubleshooting tips.\n\n## Prerequisites\n\nTo run Kyma locally, clone this Git repository to your machine and checkout the `latest` tag. After you clone the repository, run this command:\n```\ngit checkout latest\n```\nAdditionally, download these tools:\n\n- [Minikube](https://github.com/kubernetes/minikube) 0.28.2\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.10.0\n- [Helm](https://github.com/kubernetes/helm) 2.8.2\n- [jq](https://stedolan.github.io/jq/)\n\nVirtualization:\n\n- [Hyperkit driver](https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#hyperkit-driver) - Mac only\n- [VirtualBox](https://www.virtualbox.org/) - Linux or Windows\n- [Hyper-V](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v) - Windows\n\n> **NOTE:** To work with Kyma, use only the provided installation and deinstallation scripts. Kyma does not work on a basic Minikube cluster that you can start using the `minikube start` command or stop with the `minikube stop` command. If you don't need Kyma on Minikube anymore, remove the cluster with the `minikube delete` command.\n\n## Set up certificates\n\nKyma comes with a local wildcard self-signed `server.crt` certificate that you can find under the `/installation/certs/workspace/raw/` directory of the `kyma` repository. Trust it on the OS level for convenience.\n\nFollow these steps to \"always trust\" the Kyma certificate on Mac:\n\n1. Change the working directory to `installation`:\n  ```\n  cd installation\n  ```\n2. Run this command:\n  ```\n  sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain certs/workspace/raw/server.crt\n  ```\n\n>**NOTE:** \"Always trusting\" the certificate does not work with Mozilla Firefox.\n\n## Install Kyma on Minikube\n\nYou can install Kyma with all core subcomponents or only with the selected ones. This section describes how to install all core subcomponents. To learn how to install only the specific ones, see the **Install subcomponents** document for details.\n\n> **NOTE:** Running the installation script deletes any previously existing cluster from your Minikube.\n\n1. Change the working directory to `installation`:\n  ```\n  cd installation\n  ```\n\n2. Depending on your operating system, run `run.sh` for Mac and Linux or `run.ps1` for Windows\n  ```\n  cmd/run.sh\n  ```\n\nThe `run.sh` script does not show the progress of the Kyma installation, which allows you to perform other tasks in the terminal window. However, to see the status of the Kyma installation, run this script after you set up the cluster and the installer:\n\n```\nscripts/is-installed.sh\n```\n\nRead the **Reinstall Kyma** document to learn how to reinstall Kyma without deleting the cluster from Minikube.\nTo learn how to test Kyma, see the **Testing Kyma** document.\n\n## Verify the deployment\n\nFollow the guidelines in the subsections to confirm that your Kubernetes API Server is up and running as expected.\n\n### Access Kyma with CLI\n\nVerify the cluster deployment with the kubectl command line interface (CLI).\n\nRun this command to fetch all Pods in all Namespaces:\n\n  ``` bash\n  kubectl get pods --all-namespaces\n  ```\nThe command retrieves all Pods from all Namespaces, the status of the Pods, and their instance numbers. Check if the **STATUS** column shows `Running` for all Pods. If any of the Pods that you require do not start successfully, perform the installation again.\n\n### Access the Kyma console\n\nAccess your local Kyma instance through [this](https://console.kyma.local/) link.\n\n* Click **Login with Email** and sign in with the `admin@kyma.cx` email address and the generic password from the `dex-config-map.yaml` file in the `/resources/dex/templates/` directory.\n\n* Click the **Environments** section and select an Environment from the drop-down menu to explore Kyma further.\n\n### Access the Kubernetes Dashboard\n\nAdditionally, confirm that you can access your Kubernetes Dashboard. Run the following command to check the IP address on which Minikube is running:\n\n```bash\nminikube ip\n```\n\nThe address of your Kubernetes Dashboard looks similar to this:\n```\nhttp://{ip-address}:30000\n```\n\nSee the example of the website address:\n\n```\nhttp://192.168.64.44:30000\n```\n\n## Troubleshooting\n\nIf the installer does not respond as expected, check the installation status using the `is-installed.sh` script with the `--verbose` flag added. Run:\n```\nscripts/is-installed.sh --verbose\n```","type":"Getting Started"},{"order":"032-gs-cluster-installation","title":"Cluster Kyma installation","source":"\nThis Getting Started guide shows developers how to quickly deploy Kyma on a cluster. Kyma installs on a cluster using a proprietary installer based on a [Kubernetes operator](https://coreos.com/operators/). The document provides prerequisites, instructions on how to install Kyma on a cluster and verify the deployment, as well as the troubleshooting tips.\n\n## Prerequisites\n\nThe cluster on which you install Kyma must run Kubernetes version `1.10` or higher.\n\nPrepare these items:\n\n- A domain name such as `kyma.example.com`.\n- A wildcard TLS certificate for your cluster domain. Generate it with [**Let's Encrypt**](https://letsencrypt.org/).\n- The certificate for Remote Environments.\n- A static IP address for the Kyma Istio Ingress (public external IP). Create a DNS record `*.kyma.example.com` that points to Kyma Istio Ingress IP Address.\n- A Static IP address for Remote Environments Ingress. Create a DNS record `gateway.kyma.example.com` that points to Remote Environments Ingress IP Address.\n\nSome providers don't allow to pre-allocate IP addresses, such as is the case with AWS which does not support static IP assignment during ELB creation. For such providers, you must complete the configuration after you install Kyma. See the **DNS configuration** section for more details.\n\n>**NOTE:** See the Application Connector documentation for more details on Remote Environments.\n\nConfigure the Kubernetes API Server following this template:\n\n>**NOTE:** Apply this configuration only when you set up your own cluster. This configuration does not work with managed clusters.\n\n```\n\"apiServerConfig\": {\n    \"--enable-admission-plugins\": \"Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,DefaultStorageClass,ResourceQuota\",\n    \"--runtime-config\": \"batch/v2alpha1=true,settings.k8s.io/v1alpha1=true,admissionregistration.k8s.io/v1alpha1=true\",\n    \"--cors-allowed-origins\": \".*\",\n    \"--feature-gates\": \"ReadOnlyAPIDataVolumes=false\"\n},\n\"kubeletConfig\": {\n    \"--feature-gates\": \"ReadOnlyAPIDataVolumes=false\",\n    \"--authentication-token-webhook\": \"true\",\n    \"--authorization-mode\": \"Webhook\"\n}\n```\n\n## Installation\n\nYou can install Kyma with all core subcomponents or only with the selected ones. This section describes how to install all core subcomponents. To learn how to install only the specific ones, see the **Install subcomponents** document for details.\n\n1. Create the `kyma-installer` Namespace.\n\nRun the following command:\n\n```\nkubectl create ns kyma-installer\n```\n\n2. Fill in the `installer-config-cluster.yaml.tpl` template.\n\nThe Kyma installation process requires installation data specified in the `installer-config-cluster.yaml` file. Copy the `installer-config-cluster.yaml.tpl` template, rename it to `installer-config-cluster.yaml`, and fill in these placeholder values:\n\n- `__TLS_CERT__` for the TLS certificate, this value must be a PEM format, base64-encoded TLS certifcate\n- `__TLS_KEY__` for the TLS certificate key, this value must be a base64-encoded TLS private key\n- `__REMOTE_ENV_CA__` for the Remote Environments CA\n- `__REMOTE_ENV_CA_KEY__` for the Remote Environments CA key\n- `__IS_LOCAL_INSTALLATION__` for controlling installation procedure. Set to `true` for local installation, otherwise cluster installation is assumed.\n- `__DOMAIN__` for the domain name such as `kyma.example.com`\n- `__EXTERNAL_PUBLIC_IP__` for the IP address of Kyma Istio Gateway (optional)\n- `__REMOTE_ENV_IP__` for the IP address for Remote Environments Ingress (optional)\n- `__ADMIN_GROUP__` for the additional admin group. This value is optional.\n- `__ENABLE_ETCD_BACKUP__` set to true to install the [etcd-operator][etcd-backup-operator-chart] and CronJob which executes periodically the [Etcd Backup][etcd-backup-app] application.\n- `__ETCD_BACKUP_ABS_CONTAINER_NAME__` for the Azure Blob Storage name of `etcd` backups. You can leave the value blank when the backup operator is disabled.\n\n>**NOTE:** As the `etcd` backup feature is in development, replace `__ENABLE_ETCD_BACKUP__` to `false`.\n\nWhen you fill in all required placeholder values, run the following command to provide the cluster with the installation data:\n\n```\nkubectl apply -f installer-config-cluster.yaml\n```\n\n3. Bind the default RBAC role.\n\nKyma installation requires increased permissions granted by the **cluster-admin** role. To bind the role to the default **ServiceAccount**, run the following command:\n\n```\nkubectl apply -f installation/resources/default-sa-rbac-role.yaml\n```\n\n4. Deploy `tiller`.\n\nTo deploy the `tiller` component on your cluster, run the following command:\n\n```\nkubectl apply -f installation/resources/tiller.yaml\n```\n\nWait until the `tiller` Pod is ready. Execute the following command to check that it is running:\n\n```\nkubectl get pods -n kube-system | grep tiller\n```\n\n5. Deploy the `Installer` component.\n\nTo deploy the `Installer` component on your cluster, run this command:\n\n```\nkubectl apply -f installation/resources/installer.yaml -n kyma-installer\n```\n\n6. Trigger the installation.\n\nTo trigger the installation of Kyma, you need a Custom Resource file. Duplicate the `installer-cr.yaml.tpl` file, rename it to `installer-cr.yaml`, and fill in these placeholder values:\n\n- `__VERSION__` for the version number of Kyma to install. When manually installing Kyma on a cluster, specify any valid [SemVer](https://semver.org/) notation string. For example, `0.0.1`.\n- `__URL__` for the URL to the Kyma `tar.gz` package to install. For example, for the `master` branch of Kyma, the address is `https://github.com/kyma-project/kyma/archive/master.tar.gz`.\n\n>**NOTE:** Read the **Installation** document to learn more about the Custom Resource that controls the Kyma installer.\n\nOnce the file is ready, run this command to trigger the installation:\n\n```\nkubectl apply -f installer-cr.yaml\n```\n7. Verify the installation.\n\nTo check the progress of the installation process, verify the Custom Resource:\n\n```\nkubectl get installation kyma-installation -o yaml\n```\n\nA successful installation ends by setting `status.state` to `Installed` and `status.description` to `Kyma installed`.\n\n## DNS configuration\n\nIf the cluster provider doesn't allow to pre-allocate IP addresses, the cluster gets the required details from the underlying cloud provider infrastructure. Get the allocated IP addresses and set up the DNS entries required for Kyma.\n\n- List all Services and look for \"LoadBalancer\":\n  ```\n  kubectl get services --all-namespaces | grep LoadBalancer\n  ```\n\n- Find `istio-ingressgateway` in the `istio-system` Namespace. This entry specifies the IP address for the Kyma Ingress. Create a DNS entry `*.kyma.example.com` that points to this IP address.\n\n- Find `core-nginx-ingress-controller` in the `kyma-system` Namespace. This entry specifies the IP address for the Remote Environments Ingress. Create a DNS entry `gateway.kyma.example.com` that points to this address.\n\n## Troubleshooting\n\nTo troubleshoot the installation, start by reviewing logs of the `Installer` component:\n\n```\nkubectl logs -n kyma-installer $(kubectl get pods --all-namespaces -l name=kyma-installer --no-headers -o jsonpath='{.items[*].metadata.name}')\n```\n\n[etcd-backup-app]:https://github.com/kyma-project/kyma/blob/master/tools/etcd-backup\n[etcd-backup-operator-chart]:https://github.com/kyma-project/kyma/blob/master/resources/core/charts/etcd-operator/templates/backup-deployment.yaml\n","type":"Getting Started"},{"order":"033-gs-sample-service-deployment-to-local","title":"Sample service deployment on local","source":"\nThis Getting Started guide is intended for the developers who want to quickly learn how to deploy a sample service and test it with Kyma installed locally on Mac.\n\nThis guide uses a standalone sample service written in the [Go](http://golang.org) language .\n\n## Prerequisites\n\nTo use the Kyma cluster and install the example, download these tools:\n\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.10.0\n- [curl](https://github.com/curl/curl)\n\n## Steps\n\n### Deploy and expose a sample standalone service\n\nFollow these steps:\n\n1. Deploy the sample service to any of your Environments. Use the `stage` Environment for this guide:\n\n   ```bash\n   kubectl create -n stage -f https://raw.githubusercontent.com/kyma-project/examples/master/http-db-service/deployment/deployment.yaml\n   ```\n\n2. Create an unsecured API for your example service:\n\n   ```bash\n   kubectl apply -n stage -f https://raw.githubusercontent.com/kyma-project/examples/master/gateway/service/api-without-auth.yaml\n   ```\n\n3. Add the IP address of Minikube to the `hosts` file on your local machine for your APIs:\n\n   ```bash\n   $ echo \"$(minikube ip) http-db-service.kyma.local\" | sudo tee -a /etc/hosts\n   ```\n\n4. Access the service using the following call:\n   ```bash\n   curl -ik https://http-db-service.kyma.local/orders\n   ```\n\n   The system returns a response similar to the following:\n   ```\n   HTTP/2 200\n   content-type: application/json;charset=UTF-8\n   vary: Origin\n   date: Mon, 01 Jun 2018 00:00:00 GMT\n   content-length: 2\n   x-envoy-upstream-service-time: 131\n   server: envoy\n\n   []\n   ```\n\n### Update your service's API to secure it\n\nRun the following command:\n\n   ```bash\n   kubectl apply -n stage -f https://raw.githubusercontent.com/kyma-project/examples/master/gateway/service/api-with-auth.yaml\n   ```\nAfter you apply this update, you must include a valid bearer ID token in the Authorization header to access the service.\n\n>**NOTE:** The update might take some time.\n","type":"Getting Started"},{"order":"034-gs-sample-service-deployment-to-cluster","title":"Sample service deployment on a cluster","source":"\nThis Getting Started guide is intended for the developers who want to quickly learn how to deploy a sample service and test it with the Kyma cluster.\n\nThis guide uses a standalone sample service written in the [Go](http://golang.org) language.\n\n## Prerequisites\n\nTo use the Kyma cluster and install the example, download these tools:\n\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.10.0\n- [curl](https://github.com/curl/curl)\n\n## Steps\n\n### Download configuration for kubectl\n\nFollow these steps to download **kubeconfig** and configure kubectl to access the Kyma cluster:\n1. Access the Console UI and download the **kubectl** file from the settings page.\n2. Place downloaded file in the following location: `$HOME/.kube/kubeconfig`.\n3. Point **kubectl** to the configuration file using the terminal: `export KUBECONFIG=$HOME/.kube/kubeconfig`.\n4. Confirm **kubectl** is configured to use your cluster: `kubectl cluster-info`.\n\n### Set the cluster domain variable\n\nThe commands throughout this guide use URLs that require you to provide the domain of the cluster which you are using. To complete this configuration, set the variable `yourClusterDomain` to the domain of your cluster.\n\nFor example, if your cluster's domain is `demo.cluster.kyma.cx`, run the following command:\n\n   ```bash\n   export yourClusterDomain='demo.cluster.kyma.cx'\n   ```\n\n### Deploy and expose a sample standalone service\n\nFollow these steps:\n\n1. Deploy the sample service to any of your Environments. Use the `stage` Environment for this guide:\n\n   ```bash\n   kubectl create -n stage -f https://minio.$yourClusterDomain/content/root/kyma/assets/deployment.yaml\n   ```\n\n2. Create an unsecured API for your service:\n\n   ```bash\n   curl -k https://minio.$yourClusterDomain/content/root/kyma/assets/api-without-auth.yaml |  sed \"s/.kyma.local/.$yourClusterDomain/\" | kubectl apply -n stage -f -\n   ```\n\n3. Access the service using the following call:\n   ```bash\n   curl -ik https://http-db-service.$yourClusterDomain/orders\n   ```\n\n   The system returns a response similar to the following:\n   ```\n   HTTP/2 200\n   content-type: application/json;charset=UTF-8\n   vary: Origin\n   date: Mon, 01 Jun 2018 00:00:00 GMT\n   content-length: 2\n   x-envoy-upstream-service-time: 131\n   server: envoy\n\n   []\n   ```\n\n### Update your service's API to secure it\n\nRun the following command:\n\n   ```bash\n   curl -k https://minio.$yourClusterDomain/content/root/kyma/assets/api-with-auth.yaml |  sed \"s/.kyma.local/.$yourClusterDomain/\" | kubectl apply -n stage -f -\n   ```\nAfter you apply this update, you must include a valid bearer ID token in the Authorization header to access the service.\n\n>**NOTE:** The update might take some time.\n","type":"Getting Started"},{"order":"035-gs-local-develop-no-docker","title":"Develop a service locally without using Docker","source":"\nYou can develop services in the local Kyma installation without extensive Docker knowledge or a need to build and publish a Docker image. The `minikube mount` feature allows you to mount a directory from your local disk into the local Kubernetes cluster.\n\nThis guide shows how to use this feature, using the service example implemented in Golang.\n\n## Prerequisites\n\nInstall [Golang](https://golang.org/dl/).\n\n## Steps\n\n### Install the example on your local machine\n\n1. Install the example:\n```shell\ngo get -insecure github.com/kyma-project/examples/http-db-service\n```\n2. Navigate to installed example and the `http-db-service` folder inside it:\n```shell\ncd ~/go/src/github.com/kyma-project/examples/http-db-service\n```\n3. Build the executable to run the application:\n```shell\nCGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .\n```\n\n### Mount the example directory into Minikube\n\nFor this step, you need a running local Kyma instance. Read the **Local Kyma installation** Getting Started guide to learn how to install Kyma locally.\n\n1. Open the terminal window. Do not close it until the development finishes.\n2. Mount your local drive into Minikube:\n```shell\n# Use the following pattern:\nminikube mount {LOCAL_DIR_PATH}:{CLUSTER_DIR_PATH}`\n# To follow this guide, call:\nminikube mount ~/go/src/github.com/kyma-project/examples/http-db-service:/go/src/github.com/kyma-project/examples/http-db-service\n```\n\nSee the example and expected result:\n```shell\n# Terminal 1\n$ minikube mount ~/go/src/github.com/kyma-project/examples/http-db-service:/go/src/github.com/kyma-project/examples/http-db-service\n\nMounting /Users/{USERNAME}/go/src/github.com/kyma-project/examples/http-db-service into /go/src/github.com/kyma-project/examples/http-db-service on the minikube VM\nThis daemon process must stay alive for the mount to still be accessible...\nufs starting\n```\n\n### Run your local service inside Minikube\n\n1. Create Pod that uses the base Golang image to run your executable located on your local machine:\n```shell\n# Terminal 2\nkubectl run mydevpod --image=golang:1.9.2-alpine --restart=Never -n stage --overrides='\n{\n   \"spec\":{\n      \"containers\":[\n         {\n            \"name\":\"mydevpod\",\n            \"image\":\"golang:1.9.2-alpine\",\n            \"command\": [\"./main\"],\n            \"workingDir\":\"/go/src/github.com/kyma-project/examples/http-db-service\",\n            \"volumeMounts\":[\n               {\n                  \"mountPath\":\"/go/src/github.com/kyma-project/examples/http-db-service\",\n                  \"name\":\"local-disk-mount\"\n               }\n            ]\n         }\n      ],\n      \"volumes\":[\n         {\n            \"name\":\"local-disk-mount\",\n            \"hostPath\":{\n               \"path\":\"/go/src/github.com/kyma-project/examples/http-db-service\"\n            }\n         }\n      ]\n   }\n}\n'\n```\n2. Expose the Pod as a service from Minikube to verify it:\n```shell\nkubectl expose pod mydevpod --name=mypodservice --port=8017 --type=NodePort -n stage\n```\n3. Check the Minikube IP address and Port, and use them to access your service.\n```shell\n# Get the IP address.\nminikube ip\n# See the example result: 192.168.64.44\n# Check the Port.\nkubectl get services -n stage\n# See the example result: mypodservice  NodePort 10.104.164.115  <none>  8017:32226/TCP  5m\n```\n4. Call the service from your terminal.\n```shell\ncurl {minikube ip}:{port}/orders -v\n# See the example: curl http://192.168.64.44:32226/orders -v\n# The command returns an empty array.\n```\n\n### Modify the code locally and see the results immediately in Minikube\n\n1. Edit the `main.go` file by adding a new `test` endpoint to the `startService` function\n```go\nrouter.HandleFunc(\"/test\", func (w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"test\"))\n})\n```\n2. Build a new executable to run the application inside Minikube:\n```shell\nCGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .\n```\n3. Replace the existing Pod with the new version:\n```shell\nkubectl get pod mydevpod -n stage -o yaml | kubectl replace --force -f -\n```\n4. Call the new `test` endpoint of the service from your terminal. The command returns the `Test` string:\n```shell\ncurl http://192.168.64.44:32226/test -v\n```\n","type":"Getting Started"},{"order":"036-gs-publish-service-image-and-deploy","title":"Publish a service Docker image and deploy it to Kyma","source":"\nIn the Getting Started guide for local development of a service, you can learn how to develop a service locally. You can immediately see all the changes made in the local Kyma installation based on Minikube, without building a Docker image and publishing it to a Docker registry, such as the Docker Hub.\n\nUsing the same example service, this guide explains how to build a Docker image for your service, publish it to the Docker registry, and deploy it to the local Kyma installation. The instructions base on Minikube, but you can also use the image that you create, and the Kubernetes resource definitions that you use on the Kyma cluster.\n\n>**NOTE:** The deployment works both on local Kyma installation and on the Kyma cluster.\n\n## Steps\n\n### Build a Docker image\n\nThe `http-db-service` example used in this guide provides you with the `Dockerfile` necessary for building Docker images. Examine the `Dockerfile` to learn how it looks and how it uses the Docker Multistaging feature, but do not use it one-to-one for production. There might be custom `LABEL` attributes with values to override.\n\n1. In your terminal, go to the `examples/http-db-service` directory. If you did not follow the **Sample service deployment on local** guide and you do not have this directory locally, get the `http-db-service` example from the `examples` repository.\n2. Run the build with `./build.sh`.\n\n>**NOTE:** Ensure that the new image builds and is available in your local Docker registry by calling `docker images`. Find an image called `example-http-db-service` and tagged as `latest`.\n\n### Register the image in the Docker Hub\n\nThis guide bases on Docker Hub. However, there are many other Docker registries available. You can use a private Docker registry, but it must be available in the Internet. For more details about using a private Docker registry, see the **How to deploy a Docker image from a private registry** document.\n\n1. Open the [Docker Hub](https://hub.docker.com/) webpage.\n2. Provide all of the required details and sign up.\n\n### Sign in to the Docker Hub registry in the terminal\n\n1. Call `docker login`.\n2. Provide the username and password, and select the `ENTER` key.\n\n### Push the image to the Docker Hub\n\n1. Tag the local image with a proper name required in the registry: `docker tag example-http-db-service {username}/example-http-db-service:0.0.1`.\n2. Push the image to the registry: `docker push {username}/example-http-db-service:0.0.1`.\n```shell\n#This is how it looks in the terminal\n\nThe push refers to repository [docker.io/{username}/example-http-db-service]\n4302273b9e11: Pushed\n5835bd463c0e: Pushed\n0.0.1: digest: sha256:9ec28342806f50b92c9b42fa36d979c0454aafcdda6845b362e2efb9816d1439 size: 734\n```\n>**NOTE:** To verify if the image is successfully published, check if it is available online at the following address: `https://hub.docker.com/r/{username}/example-http-db-service/`\n\n### Deploy to Kyma\n\nThe `http-db-service` example contains sample Kubernetes resource definitions needed for the basic Kyma deployment. Find them in the `deployment` folder. Perform the following modifications to use your newly-published image in the local Kyma installation:\n\n1. Go to the `deployment` directory.\n2. Edit the `deployment.yaml` file. Change the **image** attribute to `{username}/example-http-db-service:0.0.1`.\n3. Create the new resources in local Kyma using these commands: `kubectl create -f deployment.yaml -n stage && kubectl create -f ingress.yaml -n stage`.\n4. Edit your `/etc/hosts` to add the new `http-db-service.kyma.local` host to the list of hosts associated with your `minikube ip`. Follow these steps:\n    - Open a terminal window and run: `sudo vim /etc/hosts`\n    - Select the **i** key to insert a new line at the top of the file.\n    - Add this line: `{YOUR.MINIKUBE.IP} http-db-service.kyma.local`\n    - Type `:wq` and select the **Enter** key to save the changes.\n5. Run this command to check if you can access the service: `curl https://http-db-service.kyma.local/orders`. The response should return an empty array.\n","type":"Getting Started"},{"order":"040-cr-installation","title":"Installation","source":"\nThe `installations.installer.kyma-project.io` Custom Resource Definition (CRD) is a detailed description of the kind of data and the format used to control the Kyma Installer, a proprietary solution based on the\n[Kubernetes operator](https://coreos.com/operators/) principles. To get the up-to-date CRD and show the output in the `yaml` format, run this command:  \n\n```\nkubectl get crd installations.installer.kyma-project.io -o yaml\n```\n\n## Sample Custom Resource\n\nThis is a sample CR that controls the Kyma installer. This example has the **action** label set to `install`, which means that it triggers the installation of Kyma.\n\n```\napiVersion: \"installer.kyma-project.io/v1alpha1\"\nkind: Installation\nmetadata:\n  name: kyma-installation\n  labels:\n    action: install\n  finalizers:\n    - finalizer.installer.kyma-project.io\nspec:\n  version: \"1.0.0\"\n  url: \"https://sample.url.com/kyma_release.tar.gz\"\n```\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n| Field   |      Mandatory?      |  Description |\n|:----------:|:-------------:|:------|\n| **metadata.name** | **YES** | Specifies the name of the CR. |\n| **metadata.labels.action** | **YES** | Defines the behavior of the Kyma installer. Available options are `install` and `uninstall`. |\n| **metadata.finalizers** | **NO** | Protects the CR from deletion. Read [this](https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#finalizers) Kubernetes document to learn more about finalizers. |\n| **spec.version** | **NO** | When manually installing Kyma on a cluster, specify any valid [SemVer](https://semver.org/) notation string. |\n| **spec.url** | **YES** | Specifies the location of the Kyma sources `tar.gz` package. For example, for the `master` branch of Kyma, the address is `https://github.com/kyma-project/kyma/archive/master.tar.gz` |\n","type":"Custom Resource"}]},"navigation":{"topics":[{"id":"kyma","contentType":"root","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Components","anchor":"components"},{"name":"Environments","anchor":"environments"},{"name":"Reinstall Kyma","anchor":"reinstall-kyma"},{"name":"Testing Kyma","anchor":"testing-kyma"},{"name":"Charts","anchor":"charts"},{"name":"Deploy with a private Docker registry","anchor":"deploy-with-a-private-docker-registry"},{"name":"Install subcomponents","anchor":"install-subcomponents"}]},{"topicType":"Getting Started","name":"Getting Started","anchor":"getting-started","titles":[{"name":"Local Kyma installation","anchor":"local-kyma-installation"},{"name":"Cluster Kyma installation","anchor":"cluster-kyma-installation"},{"name":"Sample service deployment on local","anchor":"sample-service-deployment-on-local"},{"name":"Sample service deployment on a cluster","anchor":"sample-service-deployment-on-a-cluster"},{"name":"Develop a service locally without using Docker","anchor":"develop-a-service-locally-without-using-docker"},{"name":"Publish a service Docker image and deploy it to Kyma","anchor":"publish-a-service-docker-image-and-deploy-it-to-kyma"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Installation","anchor":"installation"}]}]},{"id":"service-catalog","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Resources","anchor":"resources"},{"name":"Add a service to the Catalog","anchor":"add-a-service-to-the-catalog"},{"name":"Provisioning and binding","anchor":"provisioning-and-binding"},{"name":"Unbinding corner case","anchor":"unbinding-corner-case"},{"name":"Etcd Database","anchor":"etcd-database"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"ServiceBindingUsage","anchor":"servicebindingusage"},{"name":"UsageKind","anchor":"usagekind"}]}]},{"id":"service-brokers","contentType":"components","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"Overview","anchor":"overview"},{"name":"Azure Broker","anchor":"azure-broker"},{"name":"Remote Environment Broker","anchor":"remote-environment-broker"},{"name":"Helm Broker","anchor":"helm-broker"}]},{"topicType":"Configuration","name":"Configuration","anchor":"configuration","titles":[{"name":"Configure Helm Broker","anchor":"configure-helm-broker"},{"name":"How to create a yBundle","anchor":"how-to-create-a-ybundle"},{"name":"Binding yBundles","anchor":"binding-ybundles"},{"name":"Enable the Azure Broker for local deployment","anchor":"enable-the-azure-broker-for-local-deployment"}]},{"topicType":"Architecture","name":"Architecture","anchor":"architecture","titles":[{"name":"The Remote Environment Broker architecture","anchor":"the-remote-environment-broker-architecture"},{"name":"Helm Broker architecture","anchor":"helm-broker-architecture"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"EventActivation","anchor":"eventactivation"}]}]},{"id":"application-connector","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Architecture","name":"Architecture","anchor":"architecture","titles":[{"name":"Application Connector components","anchor":"application-connector-components"},{"name":"Connector Service","anchor":"connector-service"},{"name":"Proxy Service","anchor":"proxy-service"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Security","anchor":"security"},{"name":"Consume applications through the Service Catalog","anchor":"consume-applications-through-the-service-catalog"},{"name":"Metadata Service","anchor":"metadata-service"},{"name":"Pass an access token in a request header","anchor":"pass-an-access-token-in-a-request-header"}]},{"topicType":"API","name":"API","anchor":"api","titles":[{"name":"Connector Service","anchor":"connector-service"},{"name":"Metadata Service","anchor":"metadata-service"},{"name":"Event Service","anchor":"event-service"}]},{"topicType":"Getting Started","name":"Getting Started","anchor":"getting-started","titles":[{"name":"Create a new Remote Environment","anchor":"create-a-new-remote-environment"},{"name":"Get the client certificate","anchor":"get-the-client-certificate"},{"name":"Register a service","anchor":"register-a-service"},{"name":"Bind a Remote Environment to an Environment","anchor":"bind-a-remote-environment-to-an-environment"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"RemoteEnvironment","anchor":"remoteenvironment"},{"name":"EnvironmentMapping","anchor":"environmentmapping"}]}]},{"id":"event-bus","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Basic concepts","anchor":"basic-concepts"},{"name":"Event flow requirements","anchor":"event-flow-requirements"},{"name":"Troubleshooting","anchor":"troubleshooting"},{"name":"Service Programming Model","anchor":"service-programming-model"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]}]},{"id":"service-mesh","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Sidecar Proxy Injection","anchor":"sidecar-proxy-injection"}]}]},{"id":"serverless","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Custom Resources","anchor":"custom-resources"},{"name":"Managing Lambdas","anchor":"managing-lambdas"},{"name":"The Node.js Programming Model","anchor":"the-node.js-programming-model"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]}]},{"id":"monitoring","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Getting Started","name":"Getting Started","anchor":"getting-started","titles":[{"name":"Expose Custom Metrics in Kyma","anchor":"expose-custom-metrics-in-kyma"}]}]},{"id":"tracing","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Propagate HTTP headers","anchor":"propagate-http-headers"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]}]},{"id":"api-gateway","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Security","anchor":"security"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Api","anchor":"api"}]}]},{"id":"authorization-and-authentication","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Kubeconfig generator","anchor":"kubeconfig-generator"},{"name":"Add an Identity Provider to Dex","anchor":"add-an-identity-provider-to-dex"},{"name":"Manage static users in Dex","anchor":"manage-static-users-in-dex"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Group","anchor":"group"}]}]},{"id":"logging","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Access OK Log","anchor":"access-ok-log"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]}]}]},"manifest":{"root":[{"displayName":"Kyma","id":"kyma"}],"components":[{"displayName":"Service Catalog","id":"service-catalog"},{"displayName":"Service Brokers","id":"service-brokers"},{"displayName":"Application Connector","id":"application-connector"},{"displayName":"Event Bus","id":"event-bus"},{"displayName":"Service Mesh","id":"service-mesh"},{"displayName":"Serverless","id":"serverless"},{"displayName":"Monitoring","id":"monitoring"},{"displayName":"Tracing","id":"tracing"},{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Authorization and Authentication","id":"authorization-and-authentication"},{"displayName":"Logging","id":"logging"}]},"assetsPath":"/assets/docs/0.4/kyma/docs/assets/","locale":"en"}}